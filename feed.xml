<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://blog.wqlee.com/</id><title>wq.lee</title><subtitle>정리하는 공간</subtitle> <updated>2022-10-19T23:37:21+09:00</updated> <author> <name>Wongyu Lee</name> <uri>https://blog.wqlee.com/</uri> </author><link rel="self" type="application/atom+xml" href="https://blog.wqlee.com/feed.xml"/><link rel="alternate" type="text/html" hreflang="en" href="https://blog.wqlee.com/"/> <generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator> <rights> © 2022 Wongyu Lee </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>Linux OOM Killer</title><link href="https://blog.wqlee.com/posts/out-of-memory-kiiler/" rel="alternate" type="text/html" title="Linux OOM Killer" /><published>2022-08-20T20:00:00+09:00</published> <updated>2022-08-20T20:00:00+09:00</updated> <id>https://blog.wqlee.com/posts/out-of-memory-kiiler/</id> <content src="https://blog.wqlee.com/posts/out-of-memory-kiiler/" /> <author> <name>wq</name> </author> <category term="linux" /> <summary> OOM Killer? linux OOM Killer minikube systemd / cgroup v2 QoS Guaranteed uid: 3da16733_7851_49a0_a806_dd8a38f38ad3 containerID: 9e20d88aa83a55eacdeeb366424c7b0c5c7734213d4d9aeb4ac5e6cd4c8facfe docker@minikube:/sys/fs/cgroup/kubepods.slice/kubepods-pod3da16733_7851_49a0_a806_dd8a38f38ad3.slice/docker-9e20d88aa83a55eacdeeb366424c7b0c5c7734213d4d9aeb4ac5e6cd4c8facfe.scope$ grep "" memory.* ... </summary> </entry> <entry><title>Control groups &amp; Kubernetes</title><link href="https://blog.wqlee.com/posts/cgroups-and-kubernetes/" rel="alternate" type="text/html" title="Control groups &amp; Kubernetes" /><published>2022-08-20T20:00:00+09:00</published> <updated>2022-09-02T18:00:58+09:00</updated> <id>https://blog.wqlee.com/posts/cgroups-and-kubernetes/</id> <content src="https://blog.wqlee.com/posts/cgroups-and-kubernetes/" /> <author> <name>wq</name> </author> <category term="linux" /> <summary> Control groups? 보통 cgroups라고 불리는 control gorups는 프로세스가 사용하는 다양한 유형의 리소스를 제한하고 모니터링할 수 있는, 계층적 그룹으로 구성된 Linux kernel 기능이다. 커널의 cgroup interface는 cgroupfs라는 pseudo-filesystem을 통해 제공된다. Terminology cgorup cgorup은 cgroup filesystem을 통해 정의된 제한 또는 매개변수 집합에 바인딩된 프로세스들을 말한다. subsystem subsystem은 group에서 프로세스의 동작을 제어하는 커널의 구성 요소이다. cgorup에 허용될 CPU 및 메모리 양에 대한 제한, cgroup에서 사용하는 CPU 시간에 대한 측정,... </summary> </entry> <entry><title>Scheduling In Go II - Go Scheduler</title><link href="https://blog.wqlee.com/posts/scheduling-in-go-02/" rel="alternate" type="text/html" title="Scheduling In Go II - Go Scheduler" /><published>2022-04-19T22:00:00+09:00</published> <updated>2022-04-19T22:00:00+09:00</updated> <id>https://blog.wqlee.com/posts/scheduling-in-go-02/</id> <content src="https://blog.wqlee.com/posts/scheduling-in-go-02/" /> <author> <name>wq</name> </author> <category term="go" /> <summary> Scheduling In Go : Part II - Go Scheduler 를 옮긴 글 Prelude Go의 스케줄러 내부가 돌아가는 메커니즘(mechanics)과 의미(semantics)에 대한 이해를 제공할 3부작 시리즈의 첫번째 게시물이다. 첫번째 게시물은 운영체제 스케줄러에 중점을 둔다. 3부작: Scheduling In Go : Part I - OS Scheduler Scheduling In Go : Part II - Go Scheduler Scheduling In Go : Part III - Concurrency Introduction 스케줄링 시리즈의 첫 파트에서 Go 스케줄러의 구조를 이해하고 인지하는데 중요하다고 생각되는 운영체제의 스케줄러 관점에서 설명했... </summary> </entry> <entry><title>Scheduling In Go I - OS Scheduler</title><link href="https://blog.wqlee.com/posts/scheduling-in-go-01/" rel="alternate" type="text/html" title="Scheduling In Go I - OS Scheduler" /><published>2022-04-01T23:00:00+09:00</published> <updated>2022-04-19T23:00:34+09:00</updated> <id>https://blog.wqlee.com/posts/scheduling-in-go-01/</id> <content src="https://blog.wqlee.com/posts/scheduling-in-go-01/" /> <author> <name>wq</name> </author> <category term="go" /> <summary> Scheduling In Go : Part I - OS Scheduler 를 옮긴 글 Prelude Go의 스케줄러 내부가 돌아가는 메커니즘(mechanics)과 의미(semantics)에 대한 이해를 제공할 3부작 시리즈의 첫번째 게시물이다. 첫번째 게시물은 운영체제 스케줄러에 중점을 둔다. 3부작: Scheduling In Go : Part I - OS Scheduler Scheduling In Go : Part II - Go Scheduler Scheduling In Go : Part III - Concurrency Introduction Go 스케줄러에 적용된 설계와 동작은 멀티스레드 기반 Go 프로그램이 더육 효율적면서 좋은 성능을 발휘할 수 있게 한다. 이는 운... </summary> </entry> <entry><title>eBFP example</title><link href="https://blog.wqlee.com/posts/linux-ebpf-example/" rel="alternate" type="text/html" title="eBFP example" /><published>2022-03-24T23:00:00+09:00</published> <updated>2022-04-02T01:15:03+09:00</updated> <id>https://blog.wqlee.com/posts/linux-ebpf-example/</id> <content src="https://blog.wqlee.com/posts/linux-ebpf-example/" /> <author> <name>wq</name> </author> <category term="ebpf" /> <summary> eBPF 프로그램을 만드는 가장 흔한 방법은 C 언어로 소스 코드를 작성하고 그것을 LLVM 으로 컴파일하는 것이다. LLVM은 다양한 종류의 바이트코드를 산출할 수 있는 범용 컴파일러이며, Clang은 LLVM의 메인 프론트엔드이다. LLVM을 통해 BPF 프로그램을 컴파일해서 유효한 ELF 이진 파일(리눅스 커널이 적재할 수 있는 이진 실행 파일 형식)을 만들고 커널에 적재하는 일련의 과정을 진행하고 정리해보자. cilium/ebpf를 사용해 eBPF 프로그램을 작성하고 컴파일하고, 커널에 적재하고자 한다. 전체 예제 코드는 21kyu/bpf-example에 올려두었다. eBPF Program cilium/ebpf를 사용할 때 eBPF Program은 C 언어로 작성해도 되고, Go 언어 내부... </summary> </entry> </feed>
