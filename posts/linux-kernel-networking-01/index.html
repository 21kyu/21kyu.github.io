<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="Socket Buffer" /><meta name="author" content="Wongyu Lee" /><meta property="og:locale" content="en" /><meta name="description" content="SKB나 sk_buff라고도 부르는 소켓 버퍼(socker buffer) 구조체는 전송 또는 수신된 모든 패킷에 대해 커널이 생성해서 사용하는 구조체이다. 여러 BPF 프로그램은 이 SKB를 읽어서 패킷 전달 여부를 결정하거나, 현재 소통량에 관한 통계치와 측정치를 BPF 맵에 추가한다. 또한 eBPF는 SKB의 수정도 가능하다. 최종 패킷의 대상 주소를 변경함으로써 패킷을 다른 곳으로 재지정할 수 있으며, 심지어 근본적인 구조도 바꿀 수 있다. 이런 능력을 활용하면 IPv6 전용시스템이 받은 모든 패킷을 IPv4로 변환하는 것도 가능하다." /><meta property="og:description" content="SKB나 sk_buff라고도 부르는 소켓 버퍼(socker buffer) 구조체는 전송 또는 수신된 모든 패킷에 대해 커널이 생성해서 사용하는 구조체이다. 여러 BPF 프로그램은 이 SKB를 읽어서 패킷 전달 여부를 결정하거나, 현재 소통량에 관한 통계치와 측정치를 BPF 맵에 추가한다. 또한 eBPF는 SKB의 수정도 가능하다. 최종 패킷의 대상 주소를 변경함으로써 패킷을 다른 곳으로 재지정할 수 있으며, 심지어 근본적인 구조도 바꿀 수 있다. 이런 능력을 활용하면 IPv6 전용시스템이 받은 모든 패킷을 IPv4로 변환하는 것도 가능하다." /><link rel="canonical" href="https://blog.wqlee.com/posts/linux-kernel-networking-01/" /><meta property="og:url" content="https://blog.wqlee.com/posts/linux-kernel-networking-01/" /><meta property="og:site_name" content="wq.lee" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-03-04T20:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Socket Buffer" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Wongyu Lee","url":"https://github.com/21kyu"},"dateModified":"2022-04-02T01:15:03+09:00","datePublished":"2022-03-04T20:00:00+09:00","description":"SKB나 sk_buff라고도 부르는 소켓 버퍼(socker buffer) 구조체는 전송 또는 수신된 모든 패킷에 대해 커널이 생성해서 사용하는 구조체이다. 여러 BPF 프로그램은 이 SKB를 읽어서 패킷 전달 여부를 결정하거나, 현재 소통량에 관한 통계치와 측정치를 BPF 맵에 추가한다. 또한 eBPF는 SKB의 수정도 가능하다. 최종 패킷의 대상 주소를 변경함으로써 패킷을 다른 곳으로 재지정할 수 있으며, 심지어 근본적인 구조도 바꿀 수 있다. 이런 능력을 활용하면 IPv6 전용시스템이 받은 모든 패킷을 IPv4로 변환하는 것도 가능하다.","headline":"Socket Buffer","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.wqlee.com/posts/linux-kernel-networking-01/"},"url":"https://blog.wqlee.com/posts/linux-kernel-networking-01/"}</script><title>Socket Buffer | wq.lee</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="wq.lee"><meta name="application-name" content="wq.lee"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/avata.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">wq.lee</a></div><div class="site-subtitle font-italic">룰루랄라 즐거웁다 쿠버네티스</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/21kyu" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://www.linkedin.com/in/wq-lee" aria-label="linkedin" target="_blank" rel="noopener"> <i class="fab fa-linkedin"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['qoo','kakao.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Socket Buffer</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Socket Buffer</h1><div class="post-meta text-muted"><div> By <em> <a href="https://github.com/21kyu">Wongyu Lee</a> </em></div><div class="d-flex"><div> <span> Posted <em class="timeago" data-ts="1646391600" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2022-03-04 </em> </span> <span> Updated <em class="timeago" data-ts="1648829703" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2022-04-02 </em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="3588 words"> <em>19 min</em> read</span></div></div></div><div class="post-content"><p>SKB나 sk_buff라고도 부르는 소켓 버퍼(socker buffer) 구조체는 전송 또는 수신된 모든 패킷에 대해 커널이 생성해서 사용하는 구조체이다. 여러 BPF 프로그램은 이 SKB를 읽어서 패킷 전달 여부를 결정하거나, 현재 소통량에 관한 통계치와 측정치를 BPF 맵에 추가한다. 또한 eBPF는 SKB의 수정도 가능하다. 최종 패킷의 대상 주소를 변경함으로써 패킷을 다른 곳으로 재지정할 수 있으며, 심지어 근본적인 구조도 바꿀 수 있다. 이런 능력을 활용하면 IPv6 전용시스템이 받은 모든 패킷을 IPv4로 변환하는 것도 가능하다.</p><p>커널 내부 구조를 이해하면 eBPF를 이해하는데 도움이 될 것이다. 여기서 핵심은 패킷이 <code class="language-plaintext highlighter-rouge">struct sk_buff(socket buffer)</code> 구조체를 통해 커널 네트워크 스택을 통과한다는 것이다. (커널 영역) 소켓의 경우 <code class="language-plaintext highlighter-rouge">struct sock</code> 구조체에 정의되어 있는데, 이 구조체는 <code class="language-plaintext highlighter-rouge">tcp_sock</code>과 같은 소켓 프로토콜의 앞부분에 내장되어 있다. 네트워크 프로토콜은 <code class="language-plaintext highlighter-rouge">tcp_prot</code>, <code class="language-plaintext highlighter-rouge">udp_prot</code> 등의 <code class="language-plaintext highlighter-rouge">struct proto</code> 구조체를 사용해서 소켓에 연결된다.</p><p>우선 <code class="language-plaintext highlighter-rouge">sk_buff</code>를 조사해보자.</p><p><em><a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&amp;mallGb=KOR&amp;barcode=9791158390471">리눅스 커널 네트워킹</a> 의 부록 A. 리눅스 API 중 sk_buff 구조체를 정리해두고자 한다.</em></p><h3 id="socket-buffer"><span class="mr-2">socket buffer?</span><a href="#socket-buffer" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>패킷의 이동을 더 잘 이해하려면 리눅스 커널에서 패킷이 어떻게 표현되는지 알면 알수록 좋다고 한다. 리눅스 커널에서 소켓 버퍼(socket buffer)는 <code class="language-plaintext highlighter-rouge">sk_buff</code> 구조체로 표현되며 유입/유출 패킷을 나타낸다.</p><p>패킷은 로컬 장비에서 로컬 소켓으로 생성될 수 있으며(<em>로컬 호스트에서 생성된 패킷은 4계층 소켓:TCP 또는 UDP 소켓을 통해 만들어진다.</em>), (<em>소켓 API를 통해</em>) 사용자 공간 애플리케이션에서 생성된다. 소켓에는 데이터그램(datagram) 소켓과 스트림(stream) 소켓이라는 두 가지 주된 유형이 있다. 로컬에서 생성된 패킷은 네트워크 계층인 L3로 전달(<em>여기서 단편화가 발생하기도 한다.</em>)된 후 전송을 위해 네트워크 장치 드라이버(L2)로 전달된다. 패킷은 외부 또는 같은 장비 내의 다른 소켓으로 보내질 수 있다.</p><p>또한 패킷은 커널 소켓에 의해 생성될 수도 있다. 네트워크 장치(L2)로부터 물리적 프레임을 수신하고 이를 <code class="language-plaintext highlighter-rouge">sk_buff</code>에 연결(<em>netdev_alloc_skb() 함수를 호출하여 sk_buff 구조체를 할당한다</em>)한 후 네트워크 계층(L3)에 전달할 수 있다. 패킷 목적지가 로컬 장비이면 전송 계층(L4)으로 계속 이동할 것이고, 패킷 목적지가 로컬 장비가 아니라면 라우팅 테이블 규칙에 따라 포워딩될 것이다(로컬 장비가 포워딩을 지원할 경우). 패킷은 이유가 어떻든 간에 손상되면 폐기된다.</p><h3 id="sk_buff-구조체"><span class="mr-2">sk_buff 구조체</span><a href="#sk_buff-구조체" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>sk_buff 구조체를 살펴보자.</p><div class="language-c nolineno highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">sk_buff</span> <span class="p">{</span>
  <span class="k">union</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="p">{</span>
      <span class="cm">/* These two members must be first to match sk_buff_head. */</span>
      <span class="k">struct</span> <span class="n">sk_buff</span>    <span class="o">*</span><span class="n">next</span><span class="p">;</span>
      <span class="k">struct</span> <span class="n">sk_buff</span>    <span class="o">*</span><span class="n">prev</span><span class="p">;</span>

      <span class="k">union</span> <span class="p">{</span>
        <span class="c1">// dev는 SKB와 연관된 네트워크 인터페이스 장치를 나타내는 net_device 객체이다.</span>
        <span class="c1">// 간혹 그러한 네트워크 장치에 대한 NIC(network interface card)라는 용여를 접하게 될 것이다.</span>
        <span class="c1">// NIC는 패킷이 도착한 네트워크 장치나 패킷을 보낼 네트워크 장치가 될 수 있다.</span>
        <span class="c1">// 다음 포스팅에서 좀 더 자세히 정리해두자.</span>
        <span class="k">struct</span> <span class="n">net_device</span>  <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
        <span class="cm">/* Some protocols might use this space to store information,
         * while device pointer would be NULL.
         * UDP receive path is one user.
         */</span>
        <span class="kt">unsigned</span> <span class="kt">long</span>    <span class="n">dev_scratch</span><span class="p">;</span>
      <span class="p">};</span>
    <span class="p">};</span>
    <span class="k">struct</span> <span class="n">rb_node</span>    <span class="n">rbnode</span><span class="p">;</span> <span class="cm">/* used in netem, ip4 defrag, and tcp stack */</span>
    <span class="k">struct</span> <span class="n">list_head</span>  <span class="n">list</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">llist_node</span>  <span class="n">ll_node</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="k">union</span> <span class="p">{</span>
    <span class="c1">// SKB(로컬 생성 트래픽과 로컬 호스트를 목적지로 하는 트래픽에 대한)를 소유한 소켓이다. 포워딩될 패킷은 sk가 NULL이다.</span>
    <span class="c1">// 보통 소켓에 관해 이야기할 때는 사용자 공간에서 socket() 시스템 콜을 호출해 생성된 소켓을 기준으로 한다.</span>
    <span class="c1">// sock_create_kern() 함수를 호출해 생성되는 커널 소켓에 대해서도 알아둘 필요가 있다.</span>
    <span class="k">struct</span> <span class="n">sock</span>    <span class="o">*</span><span class="n">sk</span><span class="p">;</span>
    <span class="kt">int</span>      <span class="n">ip_defrag_offset</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="k">union</span> <span class="p">{</span>
    <span class="c1">// 패킷의 도착 timestamp. SKB에서 기본 timestamp로 제공돼 저장된다.</span>
    <span class="n">ktime_t</span>    <span class="n">tstamp</span><span class="p">;</span>
    <span class="n">u64</span>    <span class="n">skb_mstamp_ns</span><span class="p">;</span> <span class="cm">/* earliest departure time */</span>
  <span class="p">};</span>
  <span class="cm">/*
   * This is the control buffer. It is free to use for every
   * layer. Please put your private variables there. If you
   * want to keep them across layers you have to do a skb_clone()
   * first. This is owned by whoever has the skb queued ATM.
   */</span>
  <span class="c1">// 제어 버퍼로서 다른 계층에서 자유롭게 사용될 수 있다.</span>
  <span class="c1">// 이것은 비공개 정보를 저장하는데 사용되는 불투명 영역으로 TCP 프로토콜에서는 TCP 제어 버퍼를 다음과 같이 사용한다.</span>
  <span class="c1">// #define TCP_SKB_CB(__skb) ((struct tcp_skb_cb *)&amp;((__skb)-&gt;cb[0])) @include/net/tcp.h</span>
  <span class="kt">char</span>      <span class="n">cb</span><span class="p">[</span><span class="mi">48</span><span class="p">]</span> <span class="n">__aligned</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>

  <span class="k">union</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="p">{</span>
      <span class="c1">// 목적지 항목(dst_entry) 주소. dst_entry 구조체는 특정 목적지에 대한 라우팅 항목을 나타낸다.</span>
      <span class="c1">// 각 송수신 패킷의 경우 라우팅 테이블에서 탐색을 수행한다.</span>
      <span class="c1">// 간혹 이 탐색을 FIB(Forwarding Information Base) 탐색이라 하며 이 탐색의 결과에 따라 이 패킷을 어떻게 처리할 지 결정된다.</span>
      <span class="c1">// 포워딩돼야 하는지, 포워딩돼야 한다면 어떤 인터페이스를 사용해 전송될지, 또는 던져져야 하는지, ICMP 오류 메시지를 보내야 하는지</span>
      <span class="kt">unsigned</span> <span class="kt">long</span>  <span class="n">_skb_refdst</span><span class="p">;</span>
      <span class="c1">// kfree_skb() 함수를 호출해 SKB를 해제할 때 호출되는 콜백</span>
      <span class="kt">void</span>    <span class="p">(</span><span class="o">*</span><span class="n">destructor</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
    <span class="p">};</span>
    <span class="k">struct</span> <span class="n">list_head</span>  <span class="n">tcp_tsorted_anchor</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_NET_SOCK_MSG
</span>    <span class="kt">unsigned</span> <span class="kt">long</span>    <span class="n">_sk_redir</span><span class="p">;</span>
<span class="cp">#endif
</span>  <span class="p">};</span>

<span class="cp">#if defined(CONFIG_NF_CONNTRACK) || defined(CONFIG_NF_CONNTRACK_MODULE)
</span>  <span class="kt">unsigned</span> <span class="kt">long</span>     <span class="n">_nfct</span><span class="p">;</span>
<span class="cp">#endif
</span>  <span class="c1">// 패킷 바이트의 전체 개수</span>
  <span class="kt">unsigned</span> <span class="kt">int</span>    <span class="n">len</span><span class="p">,</span>
  <span class="c1">// 데이터 길이. 이 필드는 패킷이 비선형 데이터(페이지된 데이터)를 가질 때만 사용된다.</span>
        <span class="n">data_len</span><span class="p">;</span>
  <span class="c1">// MAC(2계층) 헤더의 길이</span>
  <span class="n">__u16</span>      <span class="n">mac_len</span><span class="p">,</span>
        <span class="n">hdr_len</span><span class="p">;</span>

  <span class="cm">/* Following fields are _not_ copied in __copy_skb_header()
   * Note that queue_mapping is here mostly to fill a hole.
   */</span>
  <span class="n">__u16</span>      <span class="n">queue_mapping</span><span class="p">;</span>

<span class="cm">/* if you move cloned around you also must adapt those constants */</span>
<span class="cp">#ifdef __BIG_ENDIAN_BITFIELD
#define CLONED_MASK  (1 &lt;&lt; 7)
#else
#define CLONED_MASK  1
#endif
#define CLONED_OFFSET    offsetof(struct sk_buff, __cloned_offset)
</span>
  <span class="cm">/* private: */</span>
  <span class="n">__u8</span>      <span class="n">__cloned_offset</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
  <span class="cm">/* public: */</span>
  <span class="c1">// 패킷이 __skb_cloen() 함수로 복제되면 이 필드는 복제 패킷과 주 패킷 모두 1로 설정된다.</span>
  <span class="c1">// SKB 복제는 sk_buff struct의 사본을 생성하는 것을 의미한다. 데이터 영역은 복제본과 주 SKB 사이에 공유된다.</span>
  <span class="n">__u8</span>      <span class="n">cloned</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span>
        <span class="nl">nohdr:</span><span class="mi">1</span><span class="p">,</span>
        <span class="nl">fclone:</span><span class="mi">2</span><span class="p">,</span>
  <span class="c1">// 이 패킷은 이미 확인되어 이 패킷에 대한 통계 작업(?)이 이뤄졌다. 따라서 다시 통계 작업을 수행하지 않는다.</span>
        <span class="nl">peeked:</span><span class="mi">1</span><span class="p">,</span>
        <span class="nl">head_frag:</span><span class="mi">1</span><span class="p">,</span>
        <span class="nl">pfmemalloc:</span><span class="mi">1</span><span class="p">,</span>
        <span class="nl">pp_recycle:</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* page_pool recycle indicator */</span>
<span class="cp">#ifdef CONFIG_SKB_EXTENSIONS
</span>  <span class="n">__u8</span>      <span class="n">active_extensions</span><span class="p">;</span>
<span class="cp">#endif
</span>
  <span class="cm">/* Fields enclosed in headers group are copied
   * using a single memcpy() in __copy_skb_header()
   */</span>
  <span class="n">struct_group</span><span class="p">(</span><span class="n">headers</span><span class="p">,</span>

  <span class="cm">/* private: */</span>
  <span class="n">__u8</span>      <span class="n">__pkt_type_offset</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
  <span class="cm">/* public: */</span>
  <span class="c1">// 이더넷의 경우 패킷 타입은 이더넷 헤더의 목적지 MAC 주소에 좌우되며, eth_type_trans() 함수로 결정된다.</span>
  <span class="c1">// 브로드캐스트에 대한 PACKET_BROADCAST</span>
  <span class="c1">// 멀티캐스트에 대한 PACKET_MULTICAST</span>
  <span class="c1">// 목적지 MAC 주고가 매개변수로 전달된 장치의 MAC 주소면 PACKET_HOST</span>
  <span class="c1">// 이 조건이 일치하지 않으면 PACKET_OTHERHOST</span>
  <span class="n">__u8</span>      <span class="n">pkt_type</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span> <span class="cm">/* see PKT_TYPE_MAX */</span>
  <span class="n">__u8</span>      <span class="n">ignore_df</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
  <span class="c1">// 넷필터 패킷 추적 플래그. 이 플래그는 패킷 흐름 추적 넷필터 모듈인 xt_TRACE 모듈로 설정되며, 추적할 패킷을 표시하는데 사용된다.</span>
  <span class="n">__u8</span>      <span class="n">nf_trace</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
  <span class="n">__u8</span>      <span class="n">ip_summed</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
  <span class="n">__u8</span>      <span class="n">ooo_okay</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

  <span class="n">__u8</span>      <span class="n">l4_hash</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
  <span class="n">__u8</span>      <span class="n">sw_hash</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
  <span class="n">__u8</span>      <span class="n">wifi_acked_valid</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
  <span class="n">__u8</span>      <span class="n">wifi_acked</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
  <span class="n">__u8</span>      <span class="n">no_fcs</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
  <span class="cm">/* Indicates the inner headers are valid in the skbuff. */</span>
  <span class="c1">// 캡슐화 필드는 SKB가 캡슐화에 사용됨을 의미한다.</span>
  <span class="c1">// 예를 들면 VXLAN 드라이버에서 사용된다. VXLAN은 UDP 커널 소켓을 통해 2계층 이더넷 패킷을 전송하는 표준 프로토콜이다.</span>
  <span class="c1">// 이 프로토콜은 터널을 차단하고 TCP나 UDP 통신만 허용하는 방화벽이 있을 경우 솔루션으로 사용될 수 있다.</span>
  <span class="c1">// VXLAN 드라이버는 UDP 캡슐화를 사용하고 SKB 캡슐화를 vxlan_init_net() 함수에서 1로 설정한다.</span>
  <span class="n">__u8</span>      <span class="n">encapsulation</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
  <span class="n">__u8</span>      <span class="n">encap_hdr_csum</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
  <span class="n">__u8</span>      <span class="n">csum_valid</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

  <span class="cm">/* private: */</span>
  <span class="n">__u8</span>      <span class="n">__pkt_vlan_present_offset</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
  <span class="cm">/* public: */</span>
  <span class="n">__u8</span>      <span class="n">vlan_present</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>  <span class="cm">/* See PKT_VLAN_PRESENT_BIT */</span>
  <span class="n">__u8</span>      <span class="n">csum_complete_sw</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
  <span class="n">__u8</span>      <span class="n">csum_level</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
  <span class="n">__u8</span>      <span class="n">csum_not_inet</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
  <span class="n">__u8</span>      <span class="n">dst_pending_confirm</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_IPV6_NDISC_NODETYPE
</span>  <span class="n">__u8</span>      <span class="n">ndisc_nodetype</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
<span class="cp">#endif
</span>
  <span class="c1">// 이 플래그는 SKB가 ipvs(IP 가상 서버)를 소유했는지를 나타낸다.</span>
  <span class="c1">// IPVS는 커널 기반 전송 계층 로드 밸런싱 솔루션이다.</span>
  <span class="n">__u8</span>      <span class="n">ipvs_property</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
  <span class="n">__u8</span>      <span class="n">inner_protocol_type</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
  <span class="n">__u8</span>      <span class="n">remcsum_offload</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_NET_SWITCHDEV
</span>  <span class="n">__u8</span>      <span class="n">offload_fwd_mark</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
  <span class="n">__u8</span>      <span class="n">offload_l3_fwd_mark</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif
#ifdef CONFIG_NET_CLS_ACT
</span>  <span class="n">__u8</span>      <span class="n">tc_skip_classify</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
  <span class="n">__u8</span>      <span class="n">tc_at_ingress</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif
</span>  <span class="n">__u8</span>      <span class="n">redirected</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_NET_REDIRECT
</span>  <span class="n">__u8</span>      <span class="n">from_ingress</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif
#ifdef CONFIG_NETFILTER_SKIP_EGRESS
</span>  <span class="n">__u8</span>      <span class="n">nf_skip_egress</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif
#ifdef CONFIG_TLS_DEVICE
</span>  <span class="n">__u8</span>      <span class="n">decrypted</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif
</span>  <span class="n">__u8</span>      <span class="n">slow_gro</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_NET_SCHED
</span>  <span class="n">__u16</span>      <span class="n">tc_index</span><span class="p">;</span>  <span class="cm">/* traffic control index */</span>
<span class="cp">#endif
</span>
  <span class="k">union</span> <span class="p">{</span>
    <span class="c1">// 체크섬</span>
    <span class="n">__wsum</span>    <span class="n">csum</span><span class="p">;</span>
    <span class="k">struct</span> <span class="p">{</span>
      <span class="n">__u16</span>  <span class="n">csum_start</span><span class="p">;</span>
      <span class="n">__u16</span>  <span class="n">csum_offset</span><span class="p">;</span>
    <span class="p">};</span>
  <span class="p">};</span>
  <span class="c1">// 패킷의 큐 우선순위. Tx 경로에서 SKB의 우선순위는 소켓 우선순위(소켓의 sk_priority 필드)에 따라 설정된다.</span>
  <span class="c1">// 소켓 우선순위는 SO_PRIORITY 소켓 옵션으로 setsocket() 시스템 콜을 호출해 설정될 수 있다.</span>
  <span class="c1">// net_prio cgroup 커널 모듈을 사용하면 SKB에 대한 우선순위를 설정할 규칙을 정의할 수 있다.</span>
  <span class="c1">// 포워딩 패킷에 대한 우선순위는 IP 허데에서 TOS(서비스 타입) 필드에 따라 설정된다.</span>
  <span class="c1">// 16개의 요소로 구성된 ip_tos2prio라고 하는 테이블이 있는데 TOS에서 우선순위로 변환하는 것은 rt_tos2priority() 함수로 이뤄지며, 이때 IP 헤더의 TOS 필드에 따른다.</span>
  <span class="n">__u32</span>      <span class="n">priority</span><span class="p">;</span>
  <span class="kt">int</span>      <span class="n">skb_iif</span><span class="p">;</span>
  <span class="n">__u32</span>      <span class="n">hash</span><span class="p">;</span>
  <span class="c1">// VLAN 프로토콜이 사용됨. 보통 이는 802.1q 프로토콜이다.</span>
  <span class="n">__be16</span>      <span class="n">vlan_proto</span><span class="p">;</span>
  <span class="c1">// VLAN 태그 제어 정보(2바이트). ID와 우선순위로 구성된다. (SPT의 Bridge id, priority는 아니겠지..?)</span>
  <span class="n">__u16</span>      <span class="n">vlan_tci</span><span class="p">;</span>
<span class="cp">#if defined(CONFIG_NET_RX_BUSY_POLL) || defined(CONFIG_XPS)
</span>  <span class="k">union</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">int</span>  <span class="n">napi_id</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span>  <span class="n">sender_cpu</span><span class="p">;</span>
  <span class="p">};</span>
<span class="cp">#endif
#ifdef CONFIG_NETWORK_SECMARK
</span>  <span class="c1">// 보안 표시 필드. secmark 필드는 iptables SECMARK 대상으로 설정되며, 이는 패킷을 유효한 보안 컨텍스트로 라벨링한다.</span>
  <span class="c1">// 예를 들면,</span>
  <span class="c1">// iptables -t mangle -A INPUT -p tcp --dport 80 -j SECMARK --selctx</span>
  <span class="c1">// system_u:object_r:httpd_packet_t:s0</span>
  <span class="c1">// iptables -t mangle -A OUTPUT -p tcp --sport 80 -j SECMARK --selctx</span>
  <span class="c1">// system_u:object_r:httpd_packet_t:s0</span>
  <span class="c1">// 위 규칙에서 80번 포트에서 송수신되는 패킷을 httpd_packet_t로 고정적으로 라벨링한다.</span>
  <span class="n">__u32</span>    <span class="n">secmark</span><span class="p">;</span>
<span class="cp">#endif
</span>
  <span class="k">union</span> <span class="p">{</span>
    <span class="c1">// 이 필드는 SKB를 표시해 식별할 수 있게 한다.</span>
    <span class="c1">// 예를 들면, SKB의 mark 필드를 설정할 수 있는데, 조각(mangle) 테이블의 iptables PREROUTING 규칙에서 iptalbes MARK 대상으로 설정할 수 있다.</span>
    <span class="c1">// iptables -A PREROUTING -t mangle -i eth1 -j MARK --set-mark 0x1234</span>
    <span class="c1">// 이 규칙은 탐색을 수행하기 ㅈㅓsdp eth1의 수신 트래픽을 대상으로 모든 SKB mark 필드에 0x1234 값을 할당할 것이다.</span>
    <span class="n">__u32</span>    <span class="n">mark</span><span class="p">;</span>
    <span class="n">__u32</span>    <span class="n">reserved_tailroom</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="k">union</span> <span class="p">{</span>
    <span class="n">__be16</span>    <span class="n">inner_protocol</span><span class="p">;</span>
    <span class="n">__u8</span>    <span class="n">inner_ipproto</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="c1">// 전송 계층(L4) 헤더</span>
  <span class="n">__u16</span>      <span class="n">inner_transport_header</span><span class="p">;</span>
  <span class="c1">// 네트워크 계층(L3) 헤더</span>
  <span class="n">__u16</span>      <span class="n">inner_network_header</span><span class="p">;</span>
  <span class="c1">// 데이터 링크 계층(L2) 헤더</span>
  <span class="n">__u16</span>      <span class="n">inner_mac_header</span><span class="p">;</span>

  <span class="n">__be16</span>      <span class="n">protocol</span><span class="p">;</span>
  <span class="n">__u16</span>      <span class="n">transport_header</span><span class="p">;</span>
  <span class="n">__u16</span>      <span class="n">network_header</span><span class="p">;</span>
  <span class="n">__u16</span>      <span class="n">mac_header</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_KCOV
</span>  <span class="n">u64</span>      <span class="n">kcov_handle</span><span class="p">;</span>
<span class="cp">#endif
</span>
  <span class="p">);</span> <span class="cm">/* end headers group */</span>

  <span class="cm">/* These elements must be at the end, see alloc_skb() for details.  */</span>
  <span class="c1">// 데이터의 꼬리(tail)</span>
  <span class="n">sk_buff_data_t</span>    <span class="n">tail</span><span class="p">;</span>
  <span class="c1">// 버퍼가 끝나는 부분. tail은 end를 초과할 수 없다.</span>
  <span class="n">sk_buff_data_t</span>    <span class="n">end</span><span class="p">;</span>
  <span class="c1">// 버퍼의 머리(head)</span>
  <span class="kt">unsigned</span> <span class="kt">char</span>    <span class="o">*</span><span class="n">head</span><span class="p">,</span>
  <span class="c1">// 데이터의 머리(head). 데이터 영역은 sk_buff 할당에서 분리되어 할당된다.</span>
        <span class="o">*</span><span class="n">data</span><span class="p">;</span>
  <span class="c1">// SKB에 대해 할당된 전체 메모리(SKB 구조체 자체와 할당된 데이터 영역 크기를 포함)</span>
  <span class="kt">unsigned</span> <span class="kt">int</span>    <span class="n">truesize</span><span class="p">;</span>
  <span class="n">refcount_t</span>    <span class="n">users</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_SKB_EXTENSIONS
</span>  <span class="cm">/* only useable after checking -&gt;active_extensions != 0 */</span>
  <span class="k">struct</span> <span class="n">skb_ext</span>    <span class="o">*</span><span class="n">extensions</span><span class="p">;</span>
<span class="cp">#endif
</span><span class="p">};</span>
</pre></table></code></div></div><h4 id="basic-functions-for-sk_buff"><span class="mr-2">Basic functions for sk_buff</span><a href="#basic-functions-for-sk_buff" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>SKB의 headroom과 tailroom은 아래와 같다.</p><p><img data-src="/images/skb.png" alt="skb" width="300" data-proofer-ignore> <em>SKB의 headroom과 tailroom</em></p><p>참고: <a href="http://www.skbuff.net/skbbasic.html">Basic functions for sk_buff{}</a></p><dl><dt>void skb_reserve(struct sk_buff *skb, int len)<dd>tail을 감소시켜 빈 skb의 headroom을 증가시킨다. (headroom을 조정한다.)<dt>void *skb_push(struct sk_buff *skb, unsigned int len)<dd>skb의 데이터 포인터를 감소시키고 skb의 길이를 len만큼 증가시킨다. (headroom을 줄여서 데이터를 추가한다.)<dt>void *skb_pull(struct sk_buff *skb, unsigned int len)<dd>skb의 데이터 포인터를 증가시키고 len만큼 skb의 길이를 감소시킨다. (headroom을 늘려서 데이터를 제거한다.)<dt>void *skb_put(struct sk_buff *skb, unsigned int len)<dd>버퍼에 데이터를 추가한다. 이 함수는 skb의 버퍼에 len 바이트를 추가해서 skb의 길이를 len만큼 증가시킨다. (tailroom을 줄이고 데이터를 추가한다.)<dt>void skb_trim(struct sk_buff *skb, unsigned int len)<dd>버퍼의 데이터를 삭제한다. (tailroom을 늘려 데이터를 제거한다.)</dl></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/linux/'>linux</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/kernel/" class="post-tag no-text-decoration" >kernel</a> <a href="/tags/network/" class="post-tag no-text-decoration" >network</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Socket+Buffer+-+wq.lee&url=https%3A%2F%2Fblog.wqlee.com%2Fposts%2Flinux-kernel-networking-01%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Socket+Buffer+-+wq.lee&u=https%3A%2F%2Fblog.wqlee.com%2Fposts%2Flinux-kernel-networking-01%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fblog.wqlee.com%2Fposts%2Flinux-kernel-networking-01%2F&text=Socket+Buffer+-+wq.lee" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2Fblog.wqlee.com%2Fposts%2Flinux-kernel-networking-01%2F" data-toggle="tooltip" data-placement="top" title="Linkedin" target="_blank" rel="noopener" aria-label="Linkedin"> <i class="fa-fw fab fa-linkedin"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/cgroups-and-kubernetes/">Control groups & Kubernetes</a><li><a href="/posts/what-is-a-kubernetes-watch-event-4rd/">Event란건 어쩌면 어려운게 아닐까</a><li><a href="/posts/scheduling-in-go-01/">Scheduling In Go I - OS Scheduler</a><li><a href="/posts/what-is-a-kubernetes-watch-event-3rd/">Informer의 구조</a><li><a href="/posts/what-is-a-kubernetes-watch-event-2nd/">Watch Server에 요청이 도달하기까지의 과정</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/event/">event</a> <a class="post-tag" href="/tags/kubernetes/">kubernetes</a> <a class="post-tag" href="/tags/watch/">watch</a> <a class="post-tag" href="/tags/os/">os</a> <a class="post-tag" href="/tags/kernel/">kernel</a> <a class="post-tag" href="/tags/apiserver/">apiserver</a> <a class="post-tag" href="/tags/go/">go</a> <a class="post-tag" href="/tags/gorestful/">gorestful</a> <a class="post-tag" href="/tags/network/">network</a> <a class="post-tag" href="/tags/scheduler/">scheduler</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/linux-kernel-networking-02/"><div class="card-body"> <em class="timeago small" data-ts="1646499600" > 2022-03-06 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Network Device</h3><div class="text-muted small"><p> 리눅스 커널 네트워킹 스택에서 처리하는 3계층 중 가장 낮은 계층인 L2는 데이터 링크 계층이다. 네트워크 장치 드라이버는 이 계층에 속하며 이와 관련된 기본적인 사항에 익숙해지면 네트워크 스택을 이해하는데 큰 도움이 될 것이다. Network Interface 네트워크 인터페이스는 네트워크 연결을 위한 운영체제의 끝점이다. 인터페이스는 시스템 관...</p></div></div></a></div><div class="card"> <a href="/posts/linux-ebpf-example/"><div class="card-body"> <em class="timeago small" data-ts="1648130400" > 2022-03-24 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>eBFP example</h3><div class="text-muted small"><p> eBPF 프로그램을 만드는 가장 흔한 방법은 C 언어로 소스 코드를 작성하고 그것을 LLVM 으로 컴파일하는 것이다. LLVM은 다양한 종류의 바이트코드를 산출할 수 있는 범용 컴파일러이며, Clang은 LLVM의 메인 프론트엔드이다. LLVM을 통해 BPF 프로그램을 컴파일해서 유효한 ELF 이진 파일(리눅스 커널이 적재할 수 있는 이진 실행 파일 ...</p></div></div></a></div><div class="card"> <a href="/posts/cgroups-and-kubernetes/"><div class="card-body"> <em class="timeago small" data-ts="1660993200" > 2022-08-20 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Control groups & Kubernetes</h3><div class="text-muted small"><p> Control groups? 보통 cgroups라고 불리는 control gorups는 프로세스가 사용하는 다양한 유형의 리소스를 제한하고 모니터링할 수 있는, 계층적 그룹으로 구성된 Linux kernel 기능이다. 커널의 cgroup interface는 cgroupfs라는 pseudo-filesystem을 통해 제공된다. Terminology ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/what-is-a-kubernetes-watch-event-4rd/" class="btn btn-outline-primary" prompt="Older"><p>Event란건 어쩌면 어려운게 아닐까</p></a> <a href="/posts/linux-kernel-networking-02/" class="btn btn-outline-primary" prompt="Newer"><p>Network Device</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://www.linkedin.com/in/wq-lee">Wongyu Lee</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/event/">event</a> <a class="post-tag" href="/tags/kubernetes/">kubernetes</a> <a class="post-tag" href="/tags/watch/">watch</a> <a class="post-tag" href="/tags/os/">os</a> <a class="post-tag" href="/tags/kernel/">kernel</a> <a class="post-tag" href="/tags/apiserver/">apiserver</a> <a class="post-tag" href="/tags/go/">go</a> <a class="post-tag" href="/tags/gorestful/">gorestful</a> <a class="post-tag" href="/tags/network/">network</a> <a class="post-tag" href="/tags/scheduler/">scheduler</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-4PS0JXVL1J"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-4PS0JXVL1J'); }); </script>
