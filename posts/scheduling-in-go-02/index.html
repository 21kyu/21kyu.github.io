<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="Scheduling In Go II - Go Scheduler" /><meta name="author" content="Wongyu Lee" /><meta property="og:locale" content="en" /><meta name="description" content="Scheduling In Go : Part II - Go Scheduler 를 옮긴 글" /><meta property="og:description" content="Scheduling In Go : Part II - Go Scheduler 를 옮긴 글" /><link rel="canonical" href="https://blog.wqlee.com/posts/scheduling-in-go-02/" /><meta property="og:url" content="https://blog.wqlee.com/posts/scheduling-in-go-02/" /><meta property="og:site_name" content="wq.lee" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-04-19T22:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Scheduling In Go II - Go Scheduler" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Wongyu Lee","url":"https://github.com/21kyu"},"dateModified":"2022-04-19T22:00:00+09:00","datePublished":"2022-04-19T22:00:00+09:00","description":"Scheduling In Go : Part II - Go Scheduler 를 옮긴 글","headline":"Scheduling In Go II - Go Scheduler","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.wqlee.com/posts/scheduling-in-go-02/"},"url":"https://blog.wqlee.com/posts/scheduling-in-go-02/"}</script><title>Scheduling In Go II - Go Scheduler | wq.lee</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="wq.lee"><meta name="application-name" content="wq.lee"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/avata.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">wq.lee</a></div><div class="site-subtitle font-italic">룰루랄라 즐거웁다 쿠버네티스</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/21kyu" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://www.linkedin.com/in/wq-lee" aria-label="linkedin" target="_blank" rel="noopener"> <i class="fab fa-linkedin"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['qoo','kakao.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Scheduling In Go II - Go Scheduler</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Scheduling In Go II - Go Scheduler</h1><div class="post-meta text-muted"><div> By <em> <a href="https://github.com/21kyu">Wongyu Lee</a> </em></div><div class="d-flex"><div> <span> Posted <em class="timeago" data-ts="1650373200" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2022-04-19 </em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="7203 words"> <em>40 min</em> read</span></div></div></div><div class="post-content"><blockquote><p><a href="https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part2.html">Scheduling In Go : Part II - Go Scheduler</a> 를 옮긴 글</p></blockquote><h2 id="prelude"><span class="mr-2">Prelude</span><a href="#prelude" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Go의 스케줄러 내부가 돌아가는 메커니즘(mechanics)과 의미(semantics)에 대한 이해를 제공할 3부작 시리즈의 첫번째 게시물이다. 첫번째 게시물은 운영체제 스케줄러에 중점을 둔다.</p><p><strong>3부작</strong>:</p><ol><li><a href="https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part1.html">Scheduling In Go : Part I - OS Scheduler</a><li><a href="https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part2.html">Scheduling In Go : Part II - Go Scheduler</a><li><a href="https://www.ardanlabs.com/blog/2018/12/scheduling-in-go-part3.html">Scheduling In Go : Part III - Concurrency</a></ol><h2 id="introduction"><span class="mr-2">Introduction</span><a href="#introduction" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>스케줄링 시리즈의 첫 파트에서 Go 스케줄러의 구조를 이해하고 인지하는데 중요하다고 생각되는 운영체제의 스케줄러 관점에서 설명했다. 이번 게시글에서는 Go 스케줄러가 동작하는 방식을 의미론적 수준에서 설명하고, 고수준의 동작에 초점을 맞출 것이다. Go 스케줄러는 복잡한 시스템이며 아주 조그만 메카니컬한 세부사항은 보다는 그것이 어떻게 동작하고 행동하는지에 대한 좋은 시야를 가지는 것이 중요하다. 이는 당신이 더 나은 엔지니어링 결정을 하도록 도와줄 것이다.</p><h2 id="your-program-starts"><span class="mr-2">Your Program Starts</span><a href="#your-program-starts" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Go 프로그램이 시작될 때, 호스트 머신에서 식별되는 모든 가상 코어(virtual core)에 대해 논리 프로세서(Logical Processor) <code class="language-plaintext highlighter-rouge">P</code>가 제공된다. 물리적 코어당 여러 개의 하드웨어 스레드(hardware thread)가 있는 프로세서(Hyper-Threading<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>)가 있는 경우, 각 하드웨어 스레드는 Go 프로그램에서 가상 코어로 표시된다. 더 나은 이해를 위해 한 맥북 프로 모델의 시스템 리포트를 살펴보자.</p><p><img data-src="/images/hardware-overview.png" alt="hardware overview" data-proofer-ignore> <em>그림 1</em></p><p>4개의 물리적 코어가 있는 단일 프로세서가 있음을 확인할 수 있다. 이 리포트에서는 물리적 코어 당 하드웨어 스레드의 수를 보여주지 않지만 이 맥북 프로가 보유한 Intel Core i7 프로세서에는 물리적 코어 당 2개의 하드웨어 스레드를 가지는 하이퍼 스레딩 기능이 있다. 운영체제 스레드를 병렬로 실행하려 할 때, 8개의 가상 코어를 사용할 수 있다는것을 Go 프로그램이 알게 된다.</p><p>이를 테스트하기 위한 아래의 프로그램을 보자:</p><div class="language-go nolineno highlighter-rouge"><div class="code-header"> <span data-label-text="Go"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"fmt"</span>
	<span class="s">"runtime"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>

    <span class="c">// NumCPU returns the number of logical</span>
    <span class="c">// CPUs usable by the current process.</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">runtime</span><span class="o">.</span><span class="n">NumCPU</span><span class="p">())</span>
<span class="p">}</span>
</pre></table></code></div></div><p>그림 1.의 머신에서 이 프로그램을 실행하면 <code class="language-plaintext highlighter-rouge">NumCPU()</code> 함수 호출의 결과는 8이 될 것이다. 해당 머신에서 실행되는 모든 Go 프로그램에는 8개의 <code class="language-plaintext highlighter-rouge">P</code>가 주어진다. 모든 <code class="language-plaintext highlighter-rouge">P</code>에는 운영체제 스레드 <code class="language-plaintext highlighter-rouge">M</code>이 할당된다. 이 스레드는 여전히 운영체제에 의해 관리되며 지난 게시글에서 설명한바와 같이 운영체제는 실행을 위해 코어에 스레드를 배치할 책임이 있다. 즉, 위 머신에서 Go 프로그램을 실행할 때 작업을 수행하는데 사용가능한 8개의 스레드가 존재하며 각각 <code class="language-plaintext highlighter-rouge">P</code>에 개별적으로 연결된다.</p><p>모든 Go 프로그램에는 Go 프로그램의 실행 경로인 초기 고루틴(initial Goroutine) <code class="language-plaintext highlighter-rouge">G</code>가 주어진다. 고루틴은 본질적으로 Coroutine<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>이지만 여기는 Go 세상이므로, 문자 C를 G로 바꾼 고루틴이라 불리게 된다. 고루틴은 애플리케이션 수준의 스레드로 생각할 수 있으며 여러 면에서 운영체제의 스레드와 유사하다. 운영체제 스레드는 컨텍스트 전환을 각 코어에서 하지만, 고루틴은 운영체제 스레드 <code class="language-plaintext highlighter-rouge">M</code>에서 컨텍스트 전환이 이루어 진다.</p><p>퍼즐의 마지막 조각은 실행 큐(run queue)이다. Go 스케줄러에는 전역 실행 큐(Global Run Queue, <code class="language-plaintext highlighter-rouge">GRQ</code>)와 로컬 실행 큐(Local Run Queue,<code class="language-plaintext highlighter-rouge">LRQ</code>)라는 두 가지의 실행 큐가 있다. 각 <code class="language-plaintext highlighter-rouge">P</code>에는 <code class="language-plaintext highlighter-rouge">P</code>의 컨텍스트 내에서 실행되도록 할당된 고루틴을 관리하는 <code class="language-plaintext highlighter-rouge">LRQ</code>가 주어진다. <code class="language-plaintext highlighter-rouge">LRQ</code> 내 고루틴들은 해당 <code class="language-plaintext highlighter-rouge">P</code>에 할당된 <code class="language-plaintext highlighter-rouge">M</code>에서 컨텍스트 전환되며 각자의 작업을 위한 시간을 갖는다. <code class="language-plaintext highlighter-rouge">GRQ</code>는 아직 <code class="language-plaintext highlighter-rouge">P</code>에 할당되지 않은 고루틴들을 위한 것으로 <code class="language-plaintext highlighter-rouge">GRQ</code>에서 <code class="language-plaintext highlighter-rouge">LRQ</code>로 이동하는 고루틴들의 프로세스는 이후에 논의될 것이다.</p><p>그림 2.는 이 모든 구성 요소의 대한 전체적인 이미지를 제공한다.</p><p><img data-src="/images/goroutine-components.png" alt="goroutine components" data-proofer-ignore> <em>그림 2</em></p><h2 id="cooperating-scheduler"><span class="mr-2">Cooperating Scheduler</span><a href="#cooperating-scheduler" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>앞선 게시글에서 의논했던 바와 같이 운영체제 스케줄러는 선점형 스케줄러이며 이는 스케줄러가 특정 주어진 시간에 무엇을 할지 예상할 수 없다는 것을 의미한다. 커널이 내리는 결정은 모두 비결정적이다. 운영제체에서 실행되는 애플리케이션들은 원자적(atomic<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup>) 명령어 및 뮤텍스(mutex<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">4</a></sup>) 호출과 같은 동기화 요소들을 활용하지 않는 한 스케줄링을 통해 커널에서 내부에서 일어날 일들을 제어할 수 없다.</p><p>Go 스케줄러는 Go 런타임의 일부이며, Go 런타임은 애플리케이션에 내장되어 있다. 이는 Go 스케줄러가 커널 위의 사용자 영역<sup id="fnref:5" role="doc-noteref"><a href="#fn:5" class="footnote" rel="footnote">5</a></sup>에서 실행된다는 것을 의미한다. 현재 Go 스케줄러의 구현은 선점형 스케줄러가 아니라 협조적(cooperating<sup id="fnref:6" role="doc-noteref"><a href="#fn:6" class="footnote" rel="footnote">6</a></sup>) 스케줄러이며, 이러한 협조적 스케줄러는 스케줄링 결정을 내리기 위해 코드의 안전한 지점에서 발생하는 잘 정의된 사용자 영역의 이벤트가 필요하다. Go 협조적 스케줄러의 놀라운 점은 선점형처럼 동작한다는 것인데, 사용자는 Go 스케줄러가 무엇을 할 지 예측하기가 어렵다. 이 협력형 스케줄러에 대한 의사 결정은 개발자가 아니라 Go 런타임이 하기 때문이다. 이렇듯 Go 스케줄러를 선점형 스케줄러로 생각하는 것이 중요하며 스케줄러는 비결정적이기 때문에 크게 확장되지 않는다.</p><h2 id="goroutine-states"><span class="mr-2">Goroutine States</span><a href="#goroutine-states" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>고루틴은 스레드와 동일한 3가지 형태의 고수준 상태를 가진다. 고루틴이 수행하게될 역할을 Go 스케줄러가 지시하게 되며, 고루틴은 다음 3개의 상태 중 하나가 될 수 있다:</p><dl><dt>Waiting<dd>고루틴은 중지되었으며 작업이 계속되기 위한 무언가를 기다리고 있음을 의미한다. 이는 운영체제 시스템 콜이나 atomic 및 mutex 연산과 같은 동기화 호출을 기다리는 것과 같은 이유로 발생될 수 있다. 이러한 유형의 대기 시간은 성능 저하의 근본 원인이 된다.<dt>Runnable<dd>고루틴이 할당된 명령어들을 실행할 수 있도록 <code class="language-plaintext highlighter-rouge">M</code>에 배치되기를 원하는 상태이다. 배치되기를 원하는 고루틴들이 많이 있으면, 더 오랜 시간을 기다려야 한다. 또한 각 고루틴에게 주어질 시간의 양은 더 많은 고루틴들이 경쟁을 할수록 짧아진다. 이 유형의 대기 시간 또한 성능 저하의 원인이 된다.<dt>Executing<dd>고루틴이 <code class="language-plaintext highlighter-rouge">M</code>에 배치됐고 명령어를 실행하고 있음을 의미한다. 애플리케이션과 관련된 작업이 수행되며 모두가 원하는 것 이다.</dl><h2 id="context-switching"><span class="mr-2">Context Switching</span><a href="#context-switching" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Go 스케줄러는 컨텍스트 전환을 위한 코드 내 안전한 지점에서 발생할 잘 정의된 사용자 영역의 이벤트가 필요하다. 이러한 이벤트와 안전한 지점은 함수 호출 내에서 나타난다. 함수 호출은 Go 스케줄러의 상태에 매우 중요한 요인으로, 오늘날 (1.11 버전 이하의 Go) 함수 호출을 하지 않는 tight loop<sup id="fnref:7" role="doc-noteref"><a href="#fn:7" class="footnote" rel="footnote">7</a></sup>를 실행하면 스케줄러 및 가비지 컬렉션 내에서의 지연 시간이 발생된다. 따라서 함수 호출이 합리적인 주기 내에서 발생되는 것이 매우 중요하다.</p><blockquote><p>Node: tight loop의 선점을 허용하기 위한 Go 스케줄러 내부의 비협조적 선점 기술을 적용하기 위해 승인된 1.12 버전에 대한 <a href="https://github.com/golang/go/issues/24543">제안</a> 이 있다.</p></blockquote><p>Go 프로그램에는 스케줄러의 스케줄링 결정이 발생하도록 하는 4가지 이벤트가 존재한다.</p><dl><dt>The use of the keyword go<dd><code class="language-plaintext highlighter-rouge">go</code> 키워드는 고루틴을 생성하는 방법이다. 새로운 고루틴이 생성되면 스케줄러에게 스케줄링 결정을 내릴 수 있는 기회를 제공한다.<dt>Garbage collection<dd>GC는 자체 고루틴 세트를 사용해 실행되기 때문에, 이러한 고루틴들은 <code class="language-plaintext highlighter-rouge">M</code>에 배치된 후 실행되어야 한다. 이로 인해 GC는 스케줄링의 많은 혼란을 야기하지만 스케줄러는 고루틴이 하는 작업에 대한 해박한 지식이 있으며 현명한 스케줄링 결정을 내리기 위해 해당 지식을 십분 활용할 것이다. 이러한 현명한 스케줄링 결정 중 하나는 GC가 발생되는 동안 힙을 건드리지 않는 고루틴과 힙을 건드리려는 고루틴의 컨텍스트 전환이다. GC가 실행될 때에는 수많은 스케줄링 결정이 이루어지게 된다.<dt>System calls<dd>고루틴이 <code class="language-plaintext highlighter-rouge">M</code>이 차단되도록 만드는 시스템 콜을 발생시키게 되면 스케줄러는 해당 고루틴을 <code class="language-plaintext highlighter-rouge">M</code>에서 내리고 동일한 <code class="language-plaintext highlighter-rouge">M</code>으로 새로운 고루틴을 배치할 수 있다. 그러나, <code class="language-plaintext highlighter-rouge">P</code>에서 대기 중인 고루틴을 실행하기 위한 새로운 <code class="language-plaintext highlighter-rouge">M</code>이 필요한 경우도 있다. 이것이 어떻게 작동하는지에 대해 다음 섹션에서 더 자세히 설명하겠다.<dt>Synchronization and Orchestration<dd>아토믹, 뮤텍스 또는 채널 작업의 호출로 인해 고루틴이 차단되면 스케줄러는 새로운 고루틴이 실행되도록 컨텍스트 전환 할 수 있다. 추후에 차단된 고루틴이 실행될 수 있을 때 큐에 다시 들어가 결과적으로는 컨텍스트 전환을 통해 다시 <code class="language-plaintext highlighter-rouge">M</code>에 배치될 것이다.</dl><h2 id="asynchronous-system-calls"><span class="mr-2">Asynchronous System Calls</span><a href="#asynchronous-system-calls" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>비동기 시스템 콜을 처리할 수 있는 능력을 가진 운영체제에서는 <a href="https://go.dev/src/runtime/netpoll.go">네트워크 폴러</a> 라 불리는 것을 사용해 시스템 호출을 보다 효율적으로 처리할 수 있다. 이는 해당 운영체제 내에서 kqueue(MacOS), epoll(Linux) 또는 iocp(Windows)를 사용하여 수행된다.</p><p>네트워킹 기반 시스템 콜은 오늘날 우리가 사용하고 있는 많은 운영체제에서 비동기적으로 처리될 수 있다. 네트워크 폴러는 네트워킹 작업을 처리하는 것이 주 용도라서 그런 이름을 가지게 되었다. 네트워크 폴러를 통해 네트워킹 시스템 호출을 사용하게 되면 스케줄러는 해당 시스템 호출로 인해 고루틴이 <code class="language-plaintext highlighter-rouge">M</code>이 차단되도록 하는 것을 방지할 수 있다. 이 동작은 새로운 <code class="language-plaintext highlighter-rouge">M</code>을 생성할 필요 없이 <code class="language-plaintext highlighter-rouge">P</code>의 <code class="language-plaintext highlighter-rouge">LRQ</code>에 있는 다른 고루틴이 실행 가능하도록 <code class="language-plaintext highlighter-rouge">M</code>을 유지하며 이는 운영체제의 스케줄링 부하를 줄이는 데 도움이 된다.</p><p>예제를 살펴보자.</p><p><img data-src="/images/net-poller-1.png" alt="net poller 1" data-proofer-ignore> <em>그림 3</em></p><p>그림 3은 기본 스케줄링 다이어그램을 보여준다. <code class="language-plaintext highlighter-rouge">G1</code>은 <code class="language-plaintext highlighter-rouge">M</code>에서 실행되고 있으며 3개 이상의 고루틴들이 <code class="language-plaintext highlighter-rouge">M</code>에 배치되기 위해 <code class="language-plaintext highlighter-rouge">LRQ</code>에서 대기하고 있다. <code class="language-plaintext highlighter-rouge">Net Poller</code>는 아무런 작업도 수행하지 않는 유휴(idle) 상태이다.</p><p><img data-src="/images/net-poller-2.png" alt="net poller 2" data-proofer-ignore> <em>그림 4</em></p><p>그림 4에서 <code class="language-plaintext highlighter-rouge">G1</code>은 네트워크 시스템 콜을 수행하길 원하여 <code class="language-plaintext highlighter-rouge">Net Poller</code>로 옮겨졌으며 비동기 네트워크 시스템 호출이 처리되고 있다. <code class="language-plaintext highlighter-rouge">G1</code>이 <code class="language-plaintext highlighter-rouge">Net Poller</code>로 옮겨질 때, <code class="language-plaintext highlighter-rouge">M</code>은 <code class="language-plaintext highlighter-rouge">LRQ</code>의 다른 고루틴을 실행할 수 있게 된다. 이 경우에서는 <code class="language-plaintext highlighter-rouge">G2</code>가 컨텍스트 전환되어 <code class="language-plaintext highlighter-rouge">M</code>에 배치되었다.</p><p><img data-src="/images/net-poller-3.png" alt="net poller 3" data-proofer-ignore> <em>그림 5</em></p><p>그림 5에서는 비동기 네트워크 시스템 콜이 <code class="language-plaintext highlighter-rouge">Net Poller</code>에서 처리 완료됐으며 <code class="language-plaintext highlighter-rouge">G1</code>은 <code class="language-plaintext highlighter-rouge">P</code>의 <code class="language-plaintext highlighter-rouge">LRQ</code>로 다시 옮겨졌다. 이후에 <code class="language-plaintext highlighter-rouge">G1</code>이 컨텍스트 전환돼 <code class="language-plaintext highlighter-rouge">M</code>에 다시 배치되면 <code class="language-plaintext highlighter-rouge">G1</code>이 담당하는 Go 관련 코드가 다시 실행될 것이다. 여기에서의 가장 큰 이점이라고 한다면 네트워크 시스템 호출이 실행될 때 추가적인 <code class="language-plaintext highlighter-rouge">M</code>이 필요하지 않다는 점이다. <code class="language-plaintext highlighter-rouge">Net Poller</code>는 하나의 운영체제 스레드를 가졌으며 효율적으로 돌아가는 이벤트 루프를 처리하고 있다.</p><h2 id="synchronous-system-calls"><span class="mr-2">Synchronous System Calls</span><a href="#synchronous-system-calls" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>고루틴이 비동기적으로 동작할 수 없는 시스템 콜을 호출하길 원하면 어떻게 될까? 이 경우 네트워크 폴러는 사용될 수 없으며 시스템 콜을 호출하는 고루틴은 <code class="language-plaintext highlighter-rouge">M</code>이 차단되게 한다. 불행히도 이 동직이 발생되지 않도록 막을 방법은 없다. 비동기적으로 호출될 수 없는 시스템 콜의 한 예는 파일 기반 시스템 콜이다. CGO를 사용 중이라면, C 함수를 호출할 때 <code class="language-plaintext highlighter-rouge">M</code> 또한 차단되는 상황이 있을 수도 있다.</p><blockquote><p>Note: Windows 운영체제는 파일 기반 시스템 콜을 비동기적으로 호출할 수 있다. 기술적으로 Windows에서 실행할 때에는 네트워크 폴러를 사용할 수 있다.</p></blockquote><p><code class="language-plaintext highlighter-rouge">M</code>이 차단되게 만드는 file I/O와 같은 동기적으로 동작하는 시스템 호출에서는 어떠한 일이 발생되는지 살펴보자.</p><p><img data-src="/images/synchronous-system-calls-1.png" alt="synchronous system calls 1" data-proofer-ignore> <em>그림 6</em></p><p>그림 6은 그림 3에 이어 한번 더 기본 스케줄링 다이어그램을 보여주지만 이번에는 <code class="language-plaintext highlighter-rouge">G1</code>이 <code class="language-plaintext highlighter-rouge">M1</code>이 차단될 동기적 시스템 콜을 호출할 것이다.</p><p><img data-src="/images/synchronous-system-calls-2.png" alt="synchronous system calls 2" data-proofer-ignore> <em>그림 7</em></p><p>그림 7에서 스케줄러는 <code class="language-plaintext highlighter-rouge">G1</code>에 의해 <code class="language-plaintext highlighter-rouge">M1</code>이 차단됐음을 식별할 수 있다. 이 시점에서 스케줄러는 <code class="language-plaintext highlighter-rouge">M1</code>을 <code class="language-plaintext highlighter-rouge">G1</code>이 여전히 연결된 채로 <code class="language-plaintext highlighter-rouge">P</code>에서 분리한다. 그러면 스케줄러는 <code class="language-plaintext highlighter-rouge">P</code>가 계속 작업을 할 수 있도록 새로운 <code class="language-plaintext highlighter-rouge">M2</code>를 가져온다. <code class="language-plaintext highlighter-rouge">LRQ</code>에서 <code class="language-plaintext highlighter-rouge">G2</code>가 컨텍스트 전한되어 <code class="language-plaintext highlighter-rouge">M2</code>에 배치된다. 만약 이전에 발생됐던 위와 같은 스왑으로 인해 다른 <code class="language-plaintext highlighter-rouge">M</code>이 이미 존재하는 경우, 이 전환 작업은 새로운 <code class="language-plaintext highlighter-rouge">M</code>을 생성하는 것보다 빠를 것이다.</p><p><img data-src="/images/synchronous-system-calls-3.png" alt="synchronous system calls 3" data-proofer-ignore> <em>그림 8</em></p><p>그림 8에서는 <code class="language-plaintext highlighter-rouge">G1</code>에 의해 발생된 blocking 시스템 콜이 종료된다. 이 시점에서는 <code class="language-plaintext highlighter-rouge">G1</code>은 다시 <code class="language-plaintext highlighter-rouge">LRQ</code>에 들어가며 <code class="language-plaintext highlighter-rouge">P</code>에서 다시 작업을 이어할 수 있게 된다. <code class="language-plaintext highlighter-rouge">M1</code>은 해당 시나리오가 다시 발생될 때 사용할 수 있도록 사이드에 배치된다.</p><h2 id="work-stealing"><span class="mr-2">Work Stealing</span><a href="#work-stealing" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>스케줄러의 또 다른 측면은 작업을 훔치는 스케줄러라는 것이다. 이는 스케줄링을 효율적으로 유지하는 데 몇 가지 영역에서 도움이 된다. 예를 들어, <code class="language-plaintext highlighter-rouge">M</code>이 <code class="language-plaintext highlighter-rouge">waiting</code> 상태로 전환되면 운영체제가 <code class="language-plaintext highlighter-rouge">M</code>을 코어에서 컨텍스트 전환하기 때문에 <code class="language-plaintext highlighter-rouge">M</code>이 <code class="language-plaintext highlighter-rouge">waiting</code> 상태로 전환되는 것은 바람직하지 않다. 즉, <code class="language-plaintext highlighter-rouge">runnable</code> 상태의 고루틴이 있더라도 <code class="language-plaintext highlighter-rouge">M</code>이 코어에서 컨텍스트 전환될 때까지 <code class="language-plaintext highlighter-rouge">P</code>는 어떠한 작업도 완료할 수 없음을 의미한다. 작업 훔치기는 모든 <code class="language-plaintext highlighter-rouge">P</code>에 걸쳐 고루틴의 균형을 유지하여 작업이 더 잘 분산되고 더 효율적으로 수행되도록 도와준다.</p><p>예제를 살펴보자.</p><p><img data-src="/images/work-stealing-1.png" alt="work stealing 1" data-proofer-ignore> <em>그림 9</em></p><p>그림 9는 각각 4개의 고루틴을 포함하는 2개의 <code class="language-plaintext highlighter-rouge">P</code>와 <code class="language-plaintext highlighter-rouge">GRQ</code>에 있는 하나의 고루틴을 가진 멀티스레드 Go 프로그램을 나타낸다. 2개의 <code class="language-plaintext highlighter-rouge">P</code> 중 하나가 모든 고루틴을 빠르게 처리하면 어떤 일이 발생될까?</p><p><img data-src="/images/work-stealing-2.png" alt="work stealing 2" data-proofer-ignore> <em>그림 10</em></p><p>그림 10에서 <code class="language-plaintext highlighter-rouge">P1</code>에는 더 이상 실행할 고루틴이 없다. 하지만 <code class="language-plaintext highlighter-rouge">P2</code>의 <code class="language-plaintext highlighter-rouge">LRQ</code>에도, 외부의 <code class="language-plaintext highlighter-rouge">GRQ</code>에도 <code class="language-plaintext highlighter-rouge">runnable</code> 상태의 고루틴들이 기다리고 있다. 여유가 생긴 <code class="language-plaintext highlighter-rouge">P1</code>이 작업을 훔칠 필요가 있는 순간이라고 할 수 있겠다. 작업 훔치기(stealing work<sup id="fnref:8" role="doc-noteref"><a href="#fn:8" class="footnote" rel="footnote">8</a></sup>)의 규칙은 다음과 같다.</p><div class="language-go nolineno highlighter-rouge"><div class="code-header"> <span data-label-text="Go"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="n">runtime</span><span class="o">.</span><span class="n">schedule</span><span class="p">()</span> <span class="p">{</span>
    <span class="c">// only 1/61 of the time, check the global runnable queue for a G.</span>
    <span class="c">// if not found, check the local queue.</span>
    <span class="c">// if not found,</span>
    <span class="c">//     try to steal from other Ps.</span>
    <span class="c">//     if not, check the global runnable queue.</span>
    <span class="c">//     if not found, poll network.</span>
<span class="p">}</span>
</pre></table></code></div></div><blockquote class="prompt-info"><div><p>wq: 위의 stealing work 규칙과는 실제 코드 구현이 조금 달라보여서 추가로 정리해보고자 한다.</p></div></blockquote><ol><li>공정성을 보장하기 위해 스케줄러는 가끔(<code class="language-plaintext highlighter-rouge">schedtick%61 == 0</code>일 때 마다) <code class="language-plaintext highlighter-rouge">GRQ</code>를 확인한다. 그렇지 않으면 두 고루틴이 서로를 지속적으로 재호출하여 LRQ를 완전히 차지하게 된다.<li><code class="language-plaintext highlighter-rouge">GRQ</code>에서 찾은게 없다면 <code class="language-plaintext highlighter-rouge">LRQ</code>에서 고루틴을 가져온다.<li><code class="language-plaintext highlighter-rouge">LRQ</code>에서도 찾은게 없다면, 싫행 가능한 고루틴을 찾을 때까지 이후 작업은 차단된다.<ol><li><code class="language-plaintext highlighter-rouge">LRQ</code>를 확인한다.<li><code class="language-plaintext highlighter-rouge">GRQ</code>를 확인한다.<li>네트워크를 폴링한다. 네트워크 폴러로부터 실행 가능한 고루틴을 가져온다.<li>다른 <code class="language-plaintext highlighter-rouge">P</code>에서 작업을 훔쳐온다. 예를 들어 <code class="language-plaintext highlighter-rouge">P2</code>의 <code class="language-plaintext highlighter-rouge">LRQ</code>에 있는 고루틴의 절반을 가져와서 <code class="language-plaintext highlighter-rouge">P1</code>의 <code class="language-plaintext highlighter-rouge">LRQ</code>에 넣는다.<li>아직까지도 고루틴을 찾지 못한거면 할 일이 없는거다. 그럼에도 <code class="language-plaintext highlighter-rouge">P</code>를 그냥 포기하는 것은 아쉬우니 GC 마크 단계에 있다면 유휴 시간 마킹이라도 한다.<li>wasm일 경우, 콜백이 반환되었지만 다른 고루틴이 깨어 있지 않다면 콜백이 트리거될 때까지 실행을 일시 중지하는 이벤트 핸들러 고루틴을 깨운다.</ol></ol><p>위의 룰에 따라, <code class="language-plaintext highlighter-rouge">P1</code>은 <code class="language-plaintext highlighter-rouge">P2</code>의 LRQ에서 고루틴을 확인하고 찾은 것의 절반을 가져와야 한다.</p><blockquote class="prompt-warning"><div><p>wq: 이 부분에서 설명해주는 동작이 최신 코드 구현과는 다르므로 감안해서 보도록 하자.</p></div></blockquote><p><img data-src="/images/work-stealing-3.png" alt="work stealing 3" data-proofer-ignore> <em>그림 11</em></p><p><code class="language-plaintext highlighter-rouge">P1</code>은 <code class="language-plaintext highlighter-rouge">P2</code>의 <code class="language-plaintext highlighter-rouge">LRQ</code>로부터 절반의 고루틴을 가져와서 실행한다. 만약 <code class="language-plaintext highlighter-rouge">P2</code>가 모든 고루틴의 실행을 마치고 <code class="language-plaintext highlighter-rouge">P1</code>의 <code class="language-plaintext highlighter-rouge">LRQ</code>에도 고루틴이 없다면 어떻게 될까?</p><p><img data-src="/images/work-stealing-4.png" alt="work stealing 4" data-proofer-ignore> <em>그림 12</em></p><p>그림 12에서 <code class="language-plaintext highlighter-rouge">P2</code>는 모든 작업을 마쳤으며 고루틴 몇개를 훔칠 필요성이 생겼다. 우선 <code class="language-plaintext highlighter-rouge">P1</code>의 <code class="language-plaintext highlighter-rouge">LRQ</code>를 살펴보지만 가져올 고루틴은 보이지 않는다. 다음 순으로 <code class="language-plaintext highlighter-rouge">GRQ</code>를 확인한다. 여기에서 고루틴 <code class="language-plaintext highlighter-rouge">G9</code>을 찾을 수 있다.</p><p><img data-src="/images/work-stealing-5.png" alt="work stealing 5" data-proofer-ignore> <em>그림 13</em></p><p>그림 13에서는 <code class="language-plaintext highlighter-rouge">P2</code>는 <code class="language-plaintext highlighter-rouge">GRQ</code>의 <code class="language-plaintext highlighter-rouge">G9</code>을 훔쳐오고 해당 고루틴의 작업을 실행한다. 이러한 작업 훔치기의 장점은 <code class="language-plaintext highlighter-rouge">M</code> 모두가 바쁘게 지내며 유휴 상태가 되지 않도록 해준다는 것이다. 작업 훔치기는 내부적으로는 <code class="language-plaintext highlighter-rouge">M</code>을 회전(spinning)시키는 것으로 간주된다. 이 회전에서는 JBD가 작성한 <a href="https://rakyll.org/scheduler/">블로그 게시물</a>에서 또 다른 이점에 대해 잘 설명해주고 있다.</p><h2 id="practical-example"><span class="mr-2">Practical Example</span><a href="#practical-example" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>메커니즘과 의미에 대한 이해를 갖춘 상태에서 이 모든 것이 결합되어 Go 스케줄러가 시간이 지남에 따라 더 많은 작업을 수행할 수 있도록 하는 방법을 보여주고자 한다. 두 개의 운영체제 스레드를 사용하여 프로그램이 서로 메시지를 주고 받도록 하는 C로 작성된 멀티스레드 애플리케이션을 떠올려보자.</p><p><img data-src="/images/practical-example-1.png" alt="practical example 1" data-proofer-ignore> <em>그림 14</em></p><p>그림 14에는 메시지를 앞뒤로 전달하는 2개의 스레드가 있다. <code class="language-plaintext highlighter-rouge">Thread 1</code>이 <code class="language-plaintext highlighter-rouge">Code 1</code>에서 컨텍스트 전환되어 실행 중이므로 <code class="language-plaintext highlighter-rouge">Thread 1</code>이 <code class="language-plaintext highlighter-rouge">Thread 2</code>로 메시지를 보낼 수 있다.</p><blockquote><p>Node: 메시지가 전달되는 방식은 중요하지 않다. 중요한 것은 이 작업들이 진행되는 동안의 스레드들의 상태이다.</p></blockquote><p><img data-src="/images/practical-example-2.png" alt="practical example 2" data-proofer-ignore> <em>그림 15</em></p><p>그림 15에서 <code class="language-plaintext highlighter-rouge">Thread 1</code>이 메시지 전송을 마치면 이제 응답을 기다려야 한다. 이렇게 되면 <code class="language-plaintext highlighter-rouge">Thread 1</code>은 컨텍스트 전환되어 <code class="language-plaintext highlighter-rouge">Core 1</code>에서 내려간 후 <code class="language-plaintext highlighter-rouge">waiting</code> 상태가 된다. <code class="language-plaintext highlighter-rouge">Thread 2</code>가 메시지를 전달받으면 <code class="language-plaintext highlighter-rouge">runnable</code> 상태가 되고, 운영체제는 컨텍스트 전환을 수행해 <code class="language-plaintext highlighter-rouge">Core 2</code>에서 <code class="language-plaintext highlighter-rouge">Thread 2</code>를 실행할 수 있다. 그런 다음 <code class="language-plaintext highlighter-rouge">Thread 2</code>는 메시지를 처리하고 새로운 메시지를 <code class="language-plaintext highlighter-rouge">Thread 1</code>에게 다시 보낸다.</p><p><img data-src="/images/practical-example-3.png" alt="practical example 3" data-proofer-ignore> <em>그림 16</em></p><p>그림 16에서 <code class="language-plaintext highlighter-rouge">Thread 2</code>의 메시지가 <code class="language-plaintext highlighter-rouge">Thread 1</code>에 수신됨에 따라 스레드는 컨텍스트 전환을 다시 한 번 수행한다. 이제 <code class="language-plaintext highlighter-rouge">Thread 2</code>는 <code class="language-plaintext highlighter-rouge">executing</code> 상태에서 <code class="language-plaintext highlighter-rouge">waiting</code>로, <code class="language-plaintext highlighter-rouge">Thread 1</code>은 <code class="language-plaintext highlighter-rouge">waiting</code> 상태에서 <code class="language-plaintext highlighter-rouge">runnable</code> 상태로 컨텍스트 전환되고 최종적으로는 <code class="language-plaintext highlighter-rouge">executing</code> 상태로 다시 전환되어서 새 메시지를 처리하고 보낼 수 있게 된다.</p><p>이러한 모든 컨텍스트 전환과 상태 변경에는 작업을 빠르게 완료하기 위한 제한된 수행 시간이 필요하다. 각 컨텍스트 전환은 최대 1000 나노초의 지연 시간이 발생될 수 있으며 하드웨어가 나노초 당 12개의 명령어를 수행하기를 기대하는 상황에서는 대략 1,200개의 명령어가 컨텍스트 전환 중에는 실행되지 못한다. 이러한 스레드들도 서로 다른 코어에 배치되기 때문에 캐시 라인 누락으로 인한 추가 지연 시간이 발생될 가능성도 높다.</p><p>이제 고루틴과 Go 스케줄러를 사용하는 동일한 예제를 살펴보자.</p><p><img data-src="/images/practical-example-4.png" alt="practical example 4" data-proofer-ignore> <em>그림 17</em></p><p>그림 17엔 서로 오케스트레이션되어 메시지를 주고 받는 두 개의 고루틴이 있다. <code class="language-plaintext highlighter-rouge">G1</code>은 자신의 작업을 수행하기 위해 <code class="language-plaintext highlighter-rouge">Core 1</code>에 배치되어 있는 <code class="language-plaintext highlighter-rouge">M1</code>에서 컨텍스트 전환되며 <code class="language-plaintext highlighter-rouge">G2</code>로 메시지를 전달한다.</p><p><img data-src="/images/practical-example-5.png" alt="practical example 5" data-proofer-ignore> <em>그림 18</em></p><p>그림 18에서의 <code class="language-plaintext highlighter-rouge">G1</code> 또한 메시지 전송을 마치면 이제 응답을 기다려야 한다. <code class="language-plaintext highlighter-rouge">G1</code>은 컨텍스트 전환되어 <code class="language-plaintext highlighter-rouge">M1</code>에서 내려가고 <code class="language-plaintext highlighter-rouge">waiting</code> 상태가 된다. <code class="language-plaintext highlighter-rouge">G2</code>가 <code class="language-plaintext highlighter-rouge">G1</code>이 보낸 메시지를 전달받으면 <code class="language-plaintext highlighter-rouge">runnable</code> 상태가 된다. 이제 Go 스케줄러는 컨텍스트 전환을 수행해 <code class="language-plaintext highlighter-rouge">G2</code>가 <code class="language-plaintext highlighter-rouge">Core 1</code>에 여전히 배치되어 있는 <code class="language-plaintext highlighter-rouge">M1</code>에서 실행되게 한다. 그런 다음 <code class="language-plaintext highlighter-rouge">G2</code>는 메시지를 처리하고 새로운 메시지를 <code class="language-plaintext highlighter-rouge">G1</code>으로 전달한다.</p><p><img data-src="/images/practical-example-6.png" alt="practical example 6" data-proofer-ignore> <em>그림 19</em></p><p>그림 19에서는 <code class="language-plaintext highlighter-rouge">G2</code>에서 보낸 메시지가 <code class="language-plaintext highlighter-rouge">G1</code>에 전달됨에 따라 다시 한번 컨텍스트 전환된다. 이제 <code class="language-plaintext highlighter-rouge">G2</code>는 <code class="language-plaintext highlighter-rouge">executing</code> 상태에서 <code class="language-plaintext highlighter-rouge">waiting</code> 상태로, <code class="language-plaintext highlighter-rouge">G1</code>은 <code class="language-plaintext highlighter-rouge">waiting</code> 상태에서 <code class="language-plaintext highlighter-rouge">runnable</code> 상태로 전환된 후 최종적으로는 전달받은 메시지를 처리하고 보낼 <code class="language-plaintext highlighter-rouge">executing</code> 상태로 컨텍스트 전환된다.</p><p>표면적으로는 별반 달라진게 없다. 스레드를 사용하든 고루틴을 사용하든 컨텍스트 전환과 상태 변경은 발생될 수 밖에 없다. 그러나 스레드와 고루틴의 사용 간에는 언뜻 보기엔 명백하지 않은 큰 차이가 존재한다.</p><p>고루틴을 사용하는 경우에 모든 처리에 동일한 운영체제 스레드와 코어를 사용한다. 이는 운영체제 관점에서 운영체제 스레드는 한 순간이라도 <code class="language-plaintext highlighter-rouge">waiting</code> 상태가 되지 않는다는 것을 의미한다. 그 결과 스레드를 사용했더라면 컨텍스트 전환으로 인해 손실될 모든 명령어들은 고루틴을 사용할 때는 손실되지 않는다.</p><p>본질적으로 Go는 IO/Blocking 작업을 운영체제 수준에서 CPU-bound 작업으로 전환한다. 모든 컨텍스트 전환이 애플리케이션 수준에서 발생되기 때문에, 스레드를 사용할 때 손실됐던 컨텍스트 전환 시의 최대 12,000개의 명령어는 더이상 손실되지 않는다. Go에서는 이런 동일한 컨텍스트 전환의 비용으로 최대 200 나노초 혹은 2,400개의 명령가 소요된다. 스케줄러 또한 효율적인 캐시 라인 효율성과 NUMA를 향상시키는 데도 도움이 된다. 이것이 우리가 가상 코어보다 더 많은 스레드를 필요로 하지 않는 이유다. Go 스케줄러가 더 적은 스레드를 사용하고 각 스레드에서 더 많은 작업을 수행하고자 시도하므로 시간이 지남에 따라 더 많은 작업을 완료할 수 있으며, 이는 운영체제와 하드웨어의 부하를 줄인다.</p><h2 id="conclusion"><span class="mr-2">Conclusion</span><a href="#conclusion" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Go 스케줄러는 운영체제와 하드웨어의 작동 방식의 복잡함을 고려하여 설계되었다는 점에서 진심으로 놀라울 따음이다. 운영체제 수준에서 IO/Blocking 작업을 CPU-bound 작업으로 전환하는 기능은 시간이 지남에 따라 더 높은 CPU 처리량을 활용하는 데 큰 도움이 된다. 다시 한번 말하지만, 가상 코어보다 더 많은 스레드가 필요하지 않는 이유이며 가상 코어당 단 하나의 운영체제 스레드만으로 모든 작업(CPU 및 IO/Blocking bound)을 수행할 수 있다. 운영체제 스레드를 차단하는 시스템 호출을 필요로 하지 않는 네트워킹 앱 및 기다 앱의 경우 이러한 작업이 가능해진다.</p><p>개발자는 처리 중인 작업의 종류와 관련해 앱이 수행하는 작업을 이해해야 한다. 무한정 많은 고루틴을 만들어서는 놀라운 성능을 기대할 수 없을 것이다. <code class="language-plaintext highlighter-rouge">Less is always more</code>, 이러한 Go 스케줄러의 의미를 이해한다면 더 나은 엔지니어링 결정을 내릴 수 있다. 다음 게시물에서는 코드에 추가해야 하는 복잡성의 균형을 유지하면서, 더 나은 성능을 얻기 위해 보수적인 방식으로 동시성을 활용하는 아이디어를 살펴보도록 하겠다.</p><hr /><div class="footnotes" role="doc-endnotes"><ol><li id="fn:1" role="doc-endnote"><p><a href="https://ko.wikipedia.org/wiki/하이퍼스레딩https://ko.wikipedia.org/wiki/하이퍼스레딩">Hyper-threading: wikipedia</a> <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p><li id="fn:2" role="doc-endnote"><p><a href="https://ko.wikipedia.org/wiki/코루틴">Coroutine: wikipedia</a> <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p><li id="fn:3" role="doc-endnote"><p><a href="https://ko.wikipedia.org/wiki/선형화가능성">Linearizability: wikipedia</a> <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p><li id="fn:4" role="doc-endnote"><p><a href="https://ko.wikipedia.org/wiki/락_(컴퓨터_과학)">Lock: wikipedia</a> <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p><li id="fn:5" role="doc-endnote"><p><a href="https://ko.wikipedia.org/wiki/사용자_공간">User space: wikipedia</a> <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a></p><li id="fn:6" role="doc-endnote"><p><a href="https://en.wikipedia.org/wiki/Cooperative_multitasking">Cooperative multitasking: wikipedia</a> <a href="#fnref:6" class="reversefootnote" role="doc-backlink">&#8617;</a></p><li id="fn:7" role="doc-endnote"><p><a href="https://en.wiktionary.org/wiki/tight_loop">tight loop: wikipedia</a> <a href="#fnref:7" class="reversefootnote" role="doc-backlink">&#8617;</a></p><li id="fn:8" role="doc-endnote"><p><a href="https://go.dev/src/runtime/proc.go">Source file src/runtime/proc.go</a> <a href="#fnref:8" class="reversefootnote" role="doc-backlink">&#8617;</a></p></ol></div></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/go/'>go</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/go/" class="post-tag no-text-decoration" >go</a> <a href="/tags/scheduler/" class="post-tag no-text-decoration" >scheduler</a> <a href="/tags/os/" class="post-tag no-text-decoration" >os</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Scheduling+In+Go+II+-+Go+Scheduler+-+wq.lee&url=https%3A%2F%2Fblog.wqlee.com%2Fposts%2Fscheduling-in-go-02%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Scheduling+In+Go+II+-+Go+Scheduler+-+wq.lee&u=https%3A%2F%2Fblog.wqlee.com%2Fposts%2Fscheduling-in-go-02%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fblog.wqlee.com%2Fposts%2Fscheduling-in-go-02%2F&text=Scheduling+In+Go+II+-+Go+Scheduler+-+wq.lee" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2Fblog.wqlee.com%2Fposts%2Fscheduling-in-go-02%2F" data-toggle="tooltip" data-placement="top" title="Linkedin" target="_blank" rel="noopener" aria-label="Linkedin"> <i class="fa-fw fab fa-linkedin"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/cgroups-and-kubernetes/">Control groups & Kubernetes</a><li><a href="/posts/what-is-a-kubernetes-watch-event-4rd/">Event란건 어쩌면 어려운게 아닐까</a><li><a href="/posts/scheduling-in-go-01/">Scheduling In Go I - OS Scheduler</a><li><a href="/posts/what-is-a-kubernetes-watch-event-3rd/">Informer의 구조</a><li><a href="/posts/what-is-a-kubernetes-watch-event-2nd/">Watch Server에 요청이 도달하기까지의 과정</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/event/">event</a> <a class="post-tag" href="/tags/kubernetes/">kubernetes</a> <a class="post-tag" href="/tags/watch/">watch</a> <a class="post-tag" href="/tags/os/">os</a> <a class="post-tag" href="/tags/kernel/">kernel</a> <a class="post-tag" href="/tags/apiserver/">apiserver</a> <a class="post-tag" href="/tags/go/">go</a> <a class="post-tag" href="/tags/gorestful/">gorestful</a> <a class="post-tag" href="/tags/network/">network</a> <a class="post-tag" href="/tags/scheduler/">scheduler</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/scheduling-in-go-01/"><div class="card-body"> <em class="timeago small" data-ts="1648821600" > 2022-04-01 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Scheduling In Go I - OS Scheduler</h3><div class="text-muted small"><p> Scheduling In Go : Part I - OS Scheduler 를 옮긴 글 Prelude Go의 스케줄러 내부가 돌아가는 메커니즘(mechanics)과 의미(semantics)에 대한 이해를 제공할 3부작 시리즈의 첫번째 게시물이다. 첫번째 게시물은 운영체제 스케줄러에 중점을 둔다. 3부작: Scheduling In Go ...</p></div></div></a></div><div class="card"> <a href="/posts/cgroups-and-kubernetes/"><div class="card-body"> <em class="timeago small" data-ts="1660993200" > 2022-08-20 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Control groups & Kubernetes</h3><div class="text-muted small"><p> Control groups? 보통 cgroups라고 불리는 control gorups는 프로세스가 사용하는 다양한 유형의 리소스를 제한하고 모니터링할 수 있는, 계층적 그룹으로 구성된 Linux kernel 기능이다. 커널의 cgroup interface는 cgroupfs라는 pseudo-filesystem을 통해 제공된다. Terminology ...</p></div></div></a></div><div class="card"> <a href="/posts/out-of-memory-kiiler/"><div class="card-body"> <em class="timeago small" data-ts="1660993200" > 2022-08-20 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Linux OOM Killer</h3><div class="text-muted small"><p> OOM Killer? linux OOM Killer minikube systemd / cgroup v2 QoS Guaranteed 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 uid: 3da16733_7851_49a0_a806_dd8a38f38ad3 containerID: 9e20d88aa83a55eacdeeb...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/scheduling-in-go-01/" class="btn btn-outline-primary" prompt="Older"><p>Scheduling In Go I - OS Scheduler</p></a> <a href="/posts/cgroups-and-kubernetes/" class="btn btn-outline-primary" prompt="Newer"><p>Control groups & Kubernetes</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://www.linkedin.com/in/wq-lee">Wongyu Lee</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/event/">event</a> <a class="post-tag" href="/tags/kubernetes/">kubernetes</a> <a class="post-tag" href="/tags/watch/">watch</a> <a class="post-tag" href="/tags/os/">os</a> <a class="post-tag" href="/tags/kernel/">kernel</a> <a class="post-tag" href="/tags/apiserver/">apiserver</a> <a class="post-tag" href="/tags/go/">go</a> <a class="post-tag" href="/tags/gorestful/">gorestful</a> <a class="post-tag" href="/tags/network/">network</a> <a class="post-tag" href="/tags/scheduler/">scheduler</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-4PS0JXVL1J"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-4PS0JXVL1J'); }); </script>
