<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="Kubernetes의 Watch event는 어떻게 동작하는가" /><meta name="author" content="Wongyu Lee" /><meta property="og:locale" content="en" /><meta name="description" content="Kubernetes는 pods, deployments, services와 같은 resource들을 모니터링하고 관련 event를 추적할 수 있는 Watch 개념을 가지고 있다." /><meta property="og:description" content="Kubernetes는 pods, deployments, services와 같은 resource들을 모니터링하고 관련 event를 추적할 수 있는 Watch 개념을 가지고 있다." /><link rel="canonical" href="https://blog.wqlee.com/posts/what-is-a-kubernetes-watch-event/" /><meta property="og:url" content="https://blog.wqlee.com/posts/what-is-a-kubernetes-watch-event/" /><meta property="og:site_name" content="wq.lee" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-12-26T16:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Kubernetes의 Watch event는 어떻게 동작하는가" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Wongyu Lee","url":"https://github.com/21kyu"},"dateModified":"2022-04-11T22:51:09+09:00","datePublished":"2021-12-26T16:00:00+09:00","description":"Kubernetes는 pods, deployments, services와 같은 resource들을 모니터링하고 관련 event를 추적할 수 있는 Watch 개념을 가지고 있다.","headline":"Kubernetes의 Watch event는 어떻게 동작하는가","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.wqlee.com/posts/what-is-a-kubernetes-watch-event/"},"url":"https://blog.wqlee.com/posts/what-is-a-kubernetes-watch-event/"}</script><title>Kubernetes의 Watch event는 어떻게 동작하는가 | wq.lee</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="wq.lee"><meta name="application-name" content="wq.lee"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/avata.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">wq.lee</a></div><div class="site-subtitle font-italic">룰루랄라 즐거웁다 쿠버네티스</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/21kyu" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://www.linkedin.com/in/wq-lee" aria-label="linkedin" target="_blank" rel="noopener"> <i class="fab fa-linkedin"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['qoo','kakao.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Kubernetes의 Watch event는 어떻게 동작하는가</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Kubernetes의 Watch event는 어떻게 동작하는가</h1><div class="post-meta text-muted"><div> By <em> <a href="https://github.com/21kyu">Wongyu Lee</a> </em></div><div class="d-flex"><div> <span> Posted <em class="timeago" data-ts="1640502000" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2021-12-26 </em> </span> <span> Updated <em class="timeago" data-ts="1649685069" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2022-04-11 </em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="2767 words"> <em>15 min</em> read</span></div></div></div><div class="post-content"><p>Kubernetes는 pods, deployments, services와 같은 resource들을 모니터링하고 관련 event를 추적할 수 있는 Watch 개념을 가지고 있다.</p><p>대부분 이미 Kubernetes의 Watch 기능을 사용해봤을 것이다. 나는 Deployment 등을 배포하고 Pod의 배포 상태를 계속 보고 싶을 때 Kubectl에 <em>-w</em> 옵션을 추가해 확인하곤 했다. 또한 Controller를 구현할 때에도 Watch() Method를 사용하면 결과적으로 channel을 통해 event를 받아올 수 있어 변경 감지에 따른 동작을 정의만 해주면 됐다.</p><p>Kubernetes에서는 이러한 Watch 기능을 사용하면 API server로부터 데이터를 지속적으로 전달받는다는걸 알겠는데, 정확히 어떠한 방식으로 동작되는지 궁금해졌으므로 차근히 확인하면서 여기에 정리해놓고자 한다. 혹 글 내용에 대한 수정이 필요하다면 계속해서 업데이트할 예정이다.</p><h3 id="prerequisites"><span class="mr-2">Prerequisites</span><a href="#prerequisites" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li><a href="https://kubernetes.io/docs/tasks/tools/#kubectl">kubectl</a><li><a href="https://minikube.sigs.k8s.io/docs/">minikube</a> and <em>minikube start</em></ul><h2 id="watch-pods-via-kubectl"><span class="mr-2">Watch pods via kubectl</span><a href="#watch-pods-via-kubectl" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>최근 감명 깊게 읽은 책인 <a href="https://www.oreilly.com/library/view/programming-kubernetes/9781492047094/">Programming Kubernetes</a>에서는 Watch event를 아래와 같이 설명하고 있다.</p><ul><li><em>Watch events are sent through streaming HTTP connections between the API server and controllers to drive informers.</em></ul><p>API server는 클라이언트인 Controller와 streaming HTTP connection을 통해 데이터를 주고 받는 형태라는 말인데, 이는 또 다른 클라이언트인 Kubectl과도 같은 방식으로 데이터를 주고 받을거라 이해할 수 있을 듯 하다. 빠른 확인을 위해 먼저 Kubectl의 Watch 기능을 사용해보도록 하자. 익히 알고 있는 바와 같이 한 줄의 Kubectl command로 cluster 상에 있는 (default namespace의) Pod들을 감시할 수 있게 된다.</p><div class="language-shell nolineno highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>❯ kubectl get pods <span class="nt">--watch</span>
</pre></table></code></div></div><p>새로운 shell을 열어 <code class="language-plaintext highlighter-rouge">nginx</code> pod 하나를 배포한다.</p><div class="language-shell nolineno highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>❯ kubectl run nginx <span class="nt">--image</span><span class="o">=</span>nginx
pod/nginx created
</pre></table></code></div></div><p>이제 다시 <em>watch</em>를 걸어뒀던 shell로 돌아가면 <code class="language-plaintext highlighter-rouge">nginx</code> pod의 상태(status)가 변하는 과정을 관찰할 수 있다.</p><div class="language-shell nolineno highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>NAME    READY   STATUS              RESTARTS   AGE
nginx   0/1     Pending             0          0s
nginx   0/1     Pending             0          0s
nginx   0/1     ContainerCreating   0          0s
nginx   1/1     Running             0          14s
</pre></table></code></div></div><p>어떻게 받아오는 것인지 궁금하기에 조금 더 깊게 들여다 봐야겠다. 로그 수준<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>을 최대로 높여서 <em>watch</em> command를 걸어둔 상태로 <code class="language-plaintext highlighter-rouge">nginx-2</code> pod를 추가 배포하면 아래와 같은 로그를 만나게 된다.</p><div class="language-shell nolineno highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre>❯ kubectl get pods <span class="nt">--watch</span> <span class="nt">-v</span> 9
...
GET https://127.0.0.1:57226/api/v1/namespaces/default/pods?limit<span class="o">=</span>500
...
Response Body: <span class="o">{</span><span class="s2">"kind"</span>:<span class="s2">"Table"</span>,<span class="s2">"apiVersion"</span>:<span class="s2">"meta.k8s.io/v1"</span>,<span class="s2">"metadata"</span>:<span class="o">{</span><span class="s2">"resourceVersion"</span>:<span class="s2">"818"</span><span class="o">}</span>, ...
...
NAME    READY   STATUS    RESTARTS   AGE
nginx   1/1     Running   0          4m43s
...
GET https://127.0.0.1:57226/api/v1/namespaces/default/pods?resourceVersion<span class="o">=</span>818&amp;watch<span class="o">=</span><span class="nb">true</span>
...

<span class="c"># kubectl run nginx-2 --image=nginx</span>
nginx-2   0/1     Pending             0          0s
nginx-2   0/1     Pending             0          0s
nginx-2   0/1     ContainerCreating   0          0s
nginx-2   1/1     Running             0          5s
</pre></table></code></div></div><p>로그 중 주의 깊게 봐야될 것 같은 부분을 추려봤다. 결국 Kubectl의 <em>watch</em> command는 이렇게 동작하는걸로 보인다.</p><ol><li>Kubectl은 Kuberntes API server로 (Default Namespace의) Pod의 List를 요청한다. (여기서는 max 500으로 설정됨)<li>Pod List에 대한 응답을 받고 다시 GET 요청을 한다. 이 때, 응답의 Boby에 있었던 resourceVersion과 함께 watch도 쿼리 파라미터로 같이 보낸다.</ol><p>Kubectl이 보여주는 로그를 통해 HTTP GET 요청에 <code class="language-plaintext highlighter-rouge">?watch</code> 쿼리 파라미터를 추가해 보내게 되면 Kubernetes는 이를 <em>get</em> 동작이 아닌 <em>watch</em> 동작으로 받아들이게 된다는 걸 어림잡아 알게 됐다.</p><p>이는 Reflector가 구현해둔 <a href="https://pkg.go.dev/k8s.io/client-go/tools/cache#Reflector.ListAndWatch">ListAndWatch</a> Method의 동작과 정확히 일치하는 흐름이다. 왜 2번의 GET 요청을 하도록 구현되었을까? 그리고 <code class="language-plaintext highlighter-rouge">resourceVersion</code>은 무엇일까?</p><h2 id="list-and-watch"><span class="mr-2">List and Watch</span><a href="#list-and-watch" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Kubernetes에서는 효율적인 변경 추적을 위해, 모든 object에 존재하는 <code class="language-plaintext highlighter-rouge">resourceVersion</code> field를 사용한다고 한다. etcd와 같은 persistence layer에 영속화되는 순간에 대한 상태를 식별할 수 있는 일종의 지문으로, 상태가 변경될 때마다 <code class="language-plaintext highlighter-rouge">resourceVersion</code>도 같이 변경된다.</p><div class="table-wrapper"><table><thead><tr><th> <th>Pod List<th>nginx Pod<th>nginx-2 Pod<tbody><tr><td>kubectl run nginx …<td>1920<td>628<td>-<tr><td>kubectl run nginx-2 …<td>2137<td>628<td>1939<tr><td>kubectl edit nginx …<td>6861<td>6855<td>1939</table></div><p><em>: 상태 변경에 따른 resourceVersion 변화</em></p><p>Kubectl과 같은 클라이언트들은 object 또는 collection에 대한 초기 요청(<em>get</em> 또는 <em>list</em>)의 응답으로 받은 <code class="language-plaintext highlighter-rouge">resourceVersion</code>을 사용하여 감시 요청(<em>watch</em>)을 하게 되면, 이후에 발생되는 <em>Create</em>, <em>Update</em>, <em>Delete</em> event와 같은 후속 변경 사항을 구독할 수 있다. 이러한 내용들 때문에 2번의 요청이 요구되는 것이다. resourceVersion을 얻기 위해 첫번째 GET 요청을 하며, 해당 요청에 포함된 resourceVersion과 함께 두번째 GET 요청을 하면서 resource에 대한 정확한 구독 시점이 결정되는 것이다.</p><p><em>watch</em> 요청 시 전달되는 <code class="language-plaintext highlighter-rouge">resourceVersion</code>에 따라 변경 감지의 시작점이 달라지게 되는데 <a href="https://kubernetes.io/docs/reference/using-api/api-concepts/#semantics-for-watch">Semantics for watch</a> 에서 보다 자세한 내용을 확인할 수 있다.</p><div class="table-wrapper"><table><thead><tr><th>resourceVersion unset<th>resourceVersion=”0”<th>resourceVersion=”{value other than 0}”<tbody><tr><td>Get State and Start at Most Recent<td>Get State and Start at Any<td>Start at Exact</table></div><p>이제는 <em>watch event</em>의 동작에 대해서 어느정도 알긴 하겠다. 여기에 추가로, 어떤 방식으로 Kubernetes가 event를 주고 클라이언트가 받을 수 있게 되는지 구현에 대한 정리가 되면 더 명확해질 것으로 보인다.</p><h2 id="client-side-implementation"><span class="mr-2">Client-side Implementation</span><a href="#client-side-implementation" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>클라이언트의 구현을 따라가보자. Kubectl의 <a href="https://github.com/kubernetes/kubectl/blob/d7da6ad9f193e3afdc754527c0a5ac9390c053fb/pkg/cmd/get/get.go#L638">watch</a> 구현에서, <em>watch</em> 요청이 오면 최종적으로 <code class="language-plaintext highlighter-rouge">request.go</code>에서 생성하는 <code class="language-plaintext highlighter-rouge">watch.go</code>의 <code class="language-plaintext highlighter-rouge">watch.Interface</code>에서 channel을 꺼내 event가 도착할 때마다 출력한다. 커스텀한 Controller 또는 Webhook을 구현할 경우 resource에 대한 변경 감지가 필요한 상황(<em>e.g., Pod 생성 요청을 하고 생성이 완료될 때까지 대기</em>)이면 clientSet의 client를 통해 원하는 resource에 대해 Watch verb를 요청해 원하는 로직을 구현할 수도 있는데<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>, 이 때 얻게 되는 <code class="language-plaintext highlighter-rouge">watch.Interface</code> 역시 같은 방식으로 만들어지는 객체이다.</p><div class="language-go highlighter-rouge"><div class="code-header"> <span data-label-text="Go"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="n">watch</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">client</span><span class="o">.</span><span class="n">CoreV1</span><span class="p">()</span><span class="o">.</span><span class="n">Pods</span><span class="p">(</span><span class="n">namespace</span><span class="p">)</span><span class="o">.</span><span class="n">Watch</span><span class="p">(</span><span class="n">context</span><span class="o">.</span><span class="n">TODO</span><span class="p">(),</span> <span class="n">options</span><span class="p">)</span>
<span class="c">// ...</span>

<span class="k">for</span> <span class="n">event</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">watch</span><span class="o">.</span><span class="n">ResultChan</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">pod</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">event</span><span class="o">.</span><span class="n">Object</span><span class="o">.</span><span class="p">(</span><span class="o">*</span><span class="n">corev1</span><span class="o">.</span><span class="n">Pod</span><span class="p">)</span>
  <span class="c">// ...</span>

  <span class="k">switch</span> <span class="n">event</span><span class="o">.</span><span class="n">Type</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">watch</span><span class="o">.</span><span class="n">Added</span><span class="p">,</span> <span class="n">watch</span><span class="o">.</span><span class="n">Modified</span><span class="p">,</span> <span class="n">watch</span><span class="o">.</span><span class="n">Deleted</span><span class="p">,</span> <span class="n">watch</span><span class="o">.</span><span class="n">Bookmark</span><span class="o">:</span>
      <span class="c">// ...</span>
  <span class="k">case</span> <span class="n">watch</span><span class="o">.</span><span class="n">Error</span><span class="o">:</span>
      <span class="c">// ...</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>간단하게는 이러한 방식으로 client 객체를 통해 변경 감지가 필요한 resource의 <code class="language-plaintext highlighter-rouge">watch.Interface</code>를 받을 수 있다. <code class="language-plaintext highlighter-rouge">watch.ResultChan()</code>으로 event를 전달받을 수 있으며 Type에 따라 필요한 로직을 작성하면 된다.</p><p>클라이언트 Watcher를 위한 코드는 내부적으로 이런 형태로 구현돼 있다.</p><div file="request.go" class="language-go highlighter-rouge"><div class="code-header"> <span data-label-text="request.go"><i class="far fa-file-code"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="k">func</span> <span class="p">(</span><span class="n">r</span> <span class="o">*</span><span class="n">Request</span><span class="p">)</span> <span class="n">Watch</span><span class="p">(</span><span class="n">ctx</span> <span class="n">context</span><span class="o">.</span><span class="n">Context</span><span class="p">)</span> <span class="p">(</span><span class="n">watch</span><span class="o">.</span><span class="n">Interface</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="c">// ...</span>
  <span class="k">var</span> <span class="n">retryAfter</span> <span class="o">*</span><span class="n">RetryAfter</span>
  <span class="n">url</span> <span class="o">:=</span> <span class="n">r</span><span class="o">.</span><span class="n">URL</span><span class="p">()</span><span class="o">.</span><span class="n">String</span><span class="p">()</span>
  <span class="k">for</span> <span class="p">{</span>
    <span class="n">req</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">r</span><span class="o">.</span><span class="n">newHTTPRequest</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
      <span class="k">return</span> <span class="no">nil</span><span class="p">,</span> <span class="n">err</span>
    <span class="p">}</span>

    <span class="c">// ...</span>

    <span class="n">resp</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">client</span><span class="o">.</span><span class="n">Do</span><span class="p">(</span><span class="n">req</span><span class="p">)</span>
    <span class="c">// ...</span>
    <span class="k">if</span> <span class="n">err</span> <span class="o">==</span> <span class="no">nil</span> <span class="o">&amp;&amp;</span> <span class="n">resp</span><span class="o">.</span><span class="n">StatusCode</span> <span class="o">==</span> <span class="n">http</span><span class="o">.</span><span class="n">StatusOK</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">r</span><span class="o">.</span><span class="n">newStreamWatcher</span><span class="p">(</span><span class="n">resp</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c">// ...</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">watch.Interface</code>의 prototype들을 구현한 구현체 중 하나인 StreamWatcher를 반환하는 <a href="https://github.com/kubernetes/client-go/blob/v0.23.1/rest/request.go#L671">Watch(context.Context)</a> Method다. Golang을 공부하며 그동안 예제로 보아왔던 HTTP streaming 클라이언트측 코드 구현과 매우 흡사한걸 확인할 수 있다. streaming을 위한 <code class="language-plaintext highlighter-rouge">http.request</code> 객체를 만들고 요청을 보낸 후 응답을 받아 데이터를 지속적으로 수신받을 Decoder를 생성한다. StreamWatcher 내부에 Decoder가 존재하며 아래와 같이 구성된다.</p><div file="streamwatcher.go" class="language-go highlighter-rouge"><div class="code-header"> <span data-label-text="streamwatcher.go"><i class="far fa-file-code"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="k">func</span> <span class="n">NewStreamWatcher</span><span class="p">(</span><span class="n">d</span> <span class="n">Decoder</span><span class="p">,</span> <span class="n">r</span> <span class="n">Reporter</span><span class="p">)</span> <span class="o">*</span><span class="n">StreamWatcher</span> <span class="p">{</span>
  <span class="n">sw</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">StreamWatcher</span><span class="p">{</span>
    <span class="n">source</span><span class="o">:</span>   <span class="n">d</span><span class="p">,</span>
    <span class="n">reporter</span><span class="o">:</span> <span class="n">r</span><span class="p">,</span>
    <span class="n">result</span><span class="o">:</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="n">Event</span><span class="p">),</span>
    <span class="n">done</span><span class="o">:</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="k">struct</span><span class="p">{}),</span>
  <span class="p">}</span>
  <span class="k">go</span> <span class="n">sw</span><span class="o">.</span><span class="n">receive</span><span class="p">()</span>
  <span class="k">return</span> <span class="n">sw</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Goroutine으로 실행되는 <code class="language-plaintext highlighter-rouge">sw.receive()</code>에서 Decoder로부터 Type과 Object를 얻고 result channel로 전송한다. 이러한 result channel은 <code class="language-plaintext highlighter-rouge">ResultChan()</code> Method를 통해 가져올 수 있으므로, 변경 감지가 필요한 클라이언트는 이를 사용해 channel로부터 <a href="https://pkg.go.dev/k8s.io/apimachinery/pkg/watch#Event">Event</a> 를 수신할 수 있게 되는 것이다.</p><h2 id="server-side-implementation"><span class="mr-2">Server-side Implementation</span><a href="#server-side-implementation" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>그렇다면 서버측은 어떻게 구현되어 있을까? 코드를 샅샅히 뒤져보면 WatchServer 구조체가 존재하며 <a href="https://github.com/kubernetes/apiserver/blob/v0.23.1/pkg/endpoints/handlers/watch.go#L163">ServeHTTP</a> Method로 <em>watch</em> 응답을 제공한다는 것을 확인할 수 있다.</p><div file="watch.go" class="language-go highlighter-rouge"><div class="code-header"> <span data-label-text="watch.go"><i class="far fa-file-code"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre><td class="rouge-code"><pre><span class="k">func</span> <span class="p">(</span><span class="n">s</span> <span class="o">*</span><span class="n">WatchServer</span><span class="p">)</span> <span class="n">ServeHTTP</span><span class="p">(</span><span class="n">w</span> <span class="n">http</span><span class="o">.</span><span class="n">ResponseWriter</span><span class="p">,</span> <span class="n">req</span> <span class="o">*</span><span class="n">http</span><span class="o">.</span><span class="n">Request</span><span class="p">)</span> <span class="p">{</span>
  <span class="c">// ...</span>

  <span class="k">if</span> <span class="n">wsstream</span><span class="o">.</span><span class="n">IsWebSocketRequest</span><span class="p">(</span><span class="n">req</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">w</span><span class="o">.</span><span class="n">Header</span><span class="p">()</span><span class="o">.</span><span class="n">Set</span><span class="p">(</span><span class="s">"Content-Type"</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">MediaType</span><span class="p">)</span>
    <span class="n">websocket</span><span class="o">.</span><span class="n">Handler</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">HandleWS</span><span class="p">)</span><span class="o">.</span><span class="n">ServeHTTP</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">req</span><span class="p">)</span>
    <span class="k">return</span>
  <span class="p">}</span>

  <span class="c">// ...</span>

  <span class="n">e</span> <span class="o">:=</span> <span class="n">streaming</span><span class="o">.</span><span class="n">NewEncoder</span><span class="p">(</span><span class="n">framer</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">Encoder</span><span class="p">)</span>

  <span class="c">// ...</span>

  <span class="n">w</span><span class="o">.</span><span class="n">Header</span><span class="p">()</span><span class="o">.</span><span class="n">Set</span><span class="p">(</span><span class="s">"Content-Type"</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">MediaType</span><span class="p">)</span>
  <span class="n">w</span><span class="o">.</span><span class="n">Header</span><span class="p">()</span><span class="o">.</span><span class="n">Set</span><span class="p">(</span><span class="s">"Transfer-Encoding"</span><span class="p">,</span> <span class="s">"chunked"</span><span class="p">)</span>
  <span class="n">w</span><span class="o">.</span><span class="n">WriteHeader</span><span class="p">(</span><span class="n">http</span><span class="o">.</span><span class="n">StatusOK</span><span class="p">)</span>
  <span class="n">flusher</span><span class="o">.</span><span class="n">Flush</span><span class="p">()</span>

  <span class="c">// ...</span>
  <span class="n">ch</span> <span class="o">:=</span> <span class="n">s</span><span class="o">.</span><span class="n">Watching</span><span class="o">.</span><span class="n">ResultChan</span><span class="p">()</span>
  <span class="n">done</span> <span class="o">:=</span> <span class="n">req</span><span class="o">.</span><span class="n">Context</span><span class="p">()</span><span class="o">.</span><span class="n">Done</span><span class="p">()</span>

  <span class="k">for</span> <span class="p">{</span>
    <span class="k">select</span> <span class="p">{</span>
    <span class="c">// ...</span>
    <span class="k">case</span> <span class="n">event</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">ch</span><span class="o">:</span>
      <span class="c">// ...</span>

      <span class="k">if</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">e</span><span class="o">.</span><span class="n">Encode</span><span class="p">(</span><span class="n">outEvent</span><span class="p">);</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
        <span class="n">utilruntime</span><span class="o">.</span><span class="n">HandleError</span><span class="p">(</span><span class="n">fmt</span><span class="o">.</span><span class="n">Errorf</span><span class="p">(</span><span class="s">"unable to encode watch object %T: %v (%#v)"</span><span class="p">,</span> <span class="n">outEvent</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">e</span><span class="p">))</span>
        <span class="k">return</span>
      <span class="p">}</span>
      <span class="c">// ...</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>우선 요청에서 Connection과 Upgrade 헤더를 봐서 WebSocket 연결 요청인지 확인한다. 맞다면 WebSocket connection을 통해, 아니라면 응답의 Transfer-Encoding 헤더를 <em>chunked</em>로 설정하여 streaming HTTP connection을 통해서 일련의 인코딩된 event를 클라이언트에게 제공한다.</p><p>코드를 보면 WatchServer 또한 특정 channel로부터 event를 수신해서 최종적으로 클라이언트에게 송신하는 중간 전달자임을 확인할 수 있다.</p><p><code class="language-plaintext highlighter-rouge">ch := s.Watching.ResultChan()</code></p><p>음.. Watching 객체도 <code class="language-plaintext highlighter-rouge">watch.Interface</code>로 WatchServer가 생성될 때 외부에서 주입받아 사용이 되는데 이건 또 어디에서 오는걸까? 이 부분은 다음에 Kubernetes의 <code class="language-plaintext highlighter-rouge">Event</code>에 대해 면밀히 정리를 해보면서 추가로 확인해보도록 하자.</p><h2 id="watch-event-flow"><span class="mr-2">Watch event flow</span><a href="#watch-event-flow" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>개략적인 Watch event의 흐름은 <strong>그림 1</strong>과 같다. <img data-src="/images/watch-event-flow.png" alt="Watch event flow" data-proofer-ignore> <em>그림 1. Watch event flow</em></p><p>client-go의 clientSet을 통해 <code class="language-plaintext highlighter-rouge">Watch()</code> Method를 호출해도 그림 상의 <code class="language-plaintext highlighter-rouge">Request.Watch</code>에 도달하는 것은 동일하다.</p><h2 id="conclusion"><span class="mr-2">Conclusion</span><a href="#conclusion" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Kubernetes에서의 Watch event는 어떤 방식으로 구현돼 있는지 어떻게 동작하는지 어느정도 정리해보았다. 예상했던 바와 같이 클라이언트와 API server는 Go-based HTTP streaming via HTTP &amp; websocket으로 resource에 대한 add/update/delete 타입의 event를 전달하고 받고 있었다.</p><p>예를 들어 Pod가 생성되거나 변경되거나 삭제가 되면 일련의 event가 발생되어 전달을 받고 해당 event에 대한 부가적인 처리를 할 수 있다는 아주 기본적이면서 당연한 말이긴 하다. 내부적으로 event를 어떤 방식으로 처리하게 했는지에 대해 알면 Kubernetes와 더 가까워질 수 있을 것이다. 다음 순으로 API Server에서 Watch 요청이 어떻게 핸들링되는지, <strong>Watch Server</strong>가 생성되기까지의 과정을 확인해보자.</p><div style="text-align: center; font-weight: bold; margin-top: 100px; margin-bottom: 50px">끝.</div><hr /><div class="footnotes" role="doc-endnotes"><ol><li id="fn:1" role="doc-endnote"><p>kubectl은 -v 또는 –v 플래그를 통해 로그 수준을 지정할 수 있도록 지원하고 있다. <a href="https://kubernetes.io/docs/reference/kubectl/cheatsheet/#kubectl-output-verbosity-and-debugging">kubectl-output-verbosity-and-debugging</a> 에서 자세히 확인할 수 있다. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p><li id="fn:2" role="doc-endnote"><p><em>Watch</em>보다는 <em>Informer</em> 사용이 권장된다. 이유는 추후에 알아보도록 하자. <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p></ol></div></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/kubernetes/'>kubernetes</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/kubernetes/" class="post-tag no-text-decoration" >kubernetes</a> <a href="/tags/watch/" class="post-tag no-text-decoration" >watch</a> <a href="/tags/event/" class="post-tag no-text-decoration" >event</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Kubernetes%EC%9D%98+Watch+event%EB%8A%94+%EC%96%B4%EB%96%BB%EA%B2%8C+%EB%8F%99%EC%9E%91%ED%95%98%EB%8A%94%EA%B0%80+-+wq.lee&url=https%3A%2F%2Fblog.wqlee.com%2Fposts%2Fwhat-is-a-kubernetes-watch-event%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Kubernetes%EC%9D%98+Watch+event%EB%8A%94+%EC%96%B4%EB%96%BB%EA%B2%8C+%EB%8F%99%EC%9E%91%ED%95%98%EB%8A%94%EA%B0%80+-+wq.lee&u=https%3A%2F%2Fblog.wqlee.com%2Fposts%2Fwhat-is-a-kubernetes-watch-event%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fblog.wqlee.com%2Fposts%2Fwhat-is-a-kubernetes-watch-event%2F&text=Kubernetes%EC%9D%98+Watch+event%EB%8A%94+%EC%96%B4%EB%96%BB%EA%B2%8C+%EB%8F%99%EC%9E%91%ED%95%98%EB%8A%94%EA%B0%80+-+wq.lee" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2Fblog.wqlee.com%2Fposts%2Fwhat-is-a-kubernetes-watch-event%2F" data-toggle="tooltip" data-placement="top" title="Linkedin" target="_blank" rel="noopener" aria-label="Linkedin"> <i class="fa-fw fab fa-linkedin"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/cgroups-and-kubernetes/">Control groups & Kubernetes</a><li><a href="/posts/what-is-a-kubernetes-watch-event-4rd/">Event란건 어쩌면 어려운게 아닐까</a><li><a href="/posts/scheduling-in-go-01/">Scheduling In Go I - OS Scheduler</a><li><a href="/posts/what-is-a-kubernetes-watch-event-3rd/">Informer의 구조</a><li><a href="/posts/what-is-a-kubernetes-watch-event-2nd/">Watch Server에 요청이 도달하기까지의 과정</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/event/">event</a> <a class="post-tag" href="/tags/kubernetes/">kubernetes</a> <a class="post-tag" href="/tags/watch/">watch</a> <a class="post-tag" href="/tags/os/">os</a> <a class="post-tag" href="/tags/kernel/">kernel</a> <a class="post-tag" href="/tags/apiserver/">apiserver</a> <a class="post-tag" href="/tags/go/">go</a> <a class="post-tag" href="/tags/gorestful/">gorestful</a> <a class="post-tag" href="/tags/network/">network</a> <a class="post-tag" href="/tags/scheduler/">scheduler</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/basic-etcd/"><div class="card-body"> <em class="timeago small" data-ts="1642600800" > 2022-01-19 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Basic ETCD</h3><div class="text-muted small"><p> Highly Available Fully Replicated Strong consistency model Scalable watch mechanism Concurrency control primitives Distributed Key/Value store Distributed consensus is a fancy way to e...</p></div></div></a></div><div class="card"> <a href="/posts/what-is-a-kubernetes-watch-event-3rd/"><div class="card-body"> <em class="timeago small" data-ts="1641649500" > 2022-01-08 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Informer의 구조</h3><div class="text-muted small"><p> 일전에 정리했던 내용과 같이 클라이언트가 API server에 Watch event를 요청할 때 streaming HTTP connection을 맺어 해당 리소스의 변경에 대한 이벤트를 전달받곤 했다. 이러한 변경 감지가 필요할 때마다 API server에 접근해야하는건 Kubernetes 시스템에 부하를 줄 수도 있다. 게다가 여러 클라이언트, 컨트...</p></div></div></a></div><div class="card"> <a href="/posts/what-is-a-kubernetes-watch-event-4rd/"><div class="card-body"> <em class="timeago small" data-ts="1643454000" > 2022-01-29 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Event란건 어쩌면 어려운게 아닐까</h3><div class="text-muted small"><p> Kubernetes Architecture Kubernetes는 microservice 기반의 아키텍처가 적용되어 있다. Control Plane, Worker Node의 컴포넌트들은 개별 서비스로 구현된다. 특히 Control Plane은 Event와 함께 느슨하게 결합된 구성 요소의 원칙을 많이 접목시켜 사용하고 있다. 이러한 아키텍처의 주요 이...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <span class="btn btn-outline-primary disabled" prompt="Older"><p>-</p></span> <a href="/posts/what-is-a-kubernetes-watch-event-2nd/" class="btn btn-outline-primary" prompt="Newer"><p>Watch Server에 요청이 도달하기까지의 과정</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://www.linkedin.com/in/wq-lee">Wongyu Lee</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/event/">event</a> <a class="post-tag" href="/tags/kubernetes/">kubernetes</a> <a class="post-tag" href="/tags/watch/">watch</a> <a class="post-tag" href="/tags/os/">os</a> <a class="post-tag" href="/tags/kernel/">kernel</a> <a class="post-tag" href="/tags/apiserver/">apiserver</a> <a class="post-tag" href="/tags/go/">go</a> <a class="post-tag" href="/tags/gorestful/">gorestful</a> <a class="post-tag" href="/tags/network/">network</a> <a class="post-tag" href="/tags/scheduler/">scheduler</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-4PS0JXVL1J"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-4PS0JXVL1J'); }); </script>
